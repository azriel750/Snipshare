
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Utilisateur
 * 
 */
export type Utilisateur = $Result.DefaultSelection<Prisma.$UtilisateurPayload>
/**
 * Model Snippet
 * 
 */
export type Snippet = $Result.DefaultSelection<Prisma.$SnippetPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model aimer
 * 
 */
export type aimer = $Result.DefaultSelection<Prisma.$aimerPayload>
/**
 * Model commenter
 * 
 */
export type commenter = $Result.DefaultSelection<Prisma.$commenterPayload>
/**
 * Model snippetTag
 * 
 */
export type snippetTag = $Result.DefaultSelection<Prisma.$snippetTagPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Utilisateurs
 * const utilisateurs = await prisma.utilisateur.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Utilisateurs
   * const utilisateurs = await prisma.utilisateur.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.utilisateur`: Exposes CRUD operations for the **Utilisateur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Utilisateurs
    * const utilisateurs = await prisma.utilisateur.findMany()
    * ```
    */
  get utilisateur(): Prisma.UtilisateurDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.snippet`: Exposes CRUD operations for the **Snippet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Snippets
    * const snippets = await prisma.snippet.findMany()
    * ```
    */
  get snippet(): Prisma.SnippetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aimer`: Exposes CRUD operations for the **aimer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Aimers
    * const aimers = await prisma.aimer.findMany()
    * ```
    */
  get aimer(): Prisma.aimerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commenter`: Exposes CRUD operations for the **commenter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commenters
    * const commenters = await prisma.commenter.findMany()
    * ```
    */
  get commenter(): Prisma.commenterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.snippetTag`: Exposes CRUD operations for the **snippetTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SnippetTags
    * const snippetTags = await prisma.snippetTag.findMany()
    * ```
    */
  get snippetTag(): Prisma.snippetTagDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Utilisateur: 'Utilisateur',
    Snippet: 'Snippet',
    Tag: 'Tag',
    aimer: 'aimer',
    commenter: 'commenter',
    snippetTag: 'snippetTag'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "utilisateur" | "snippet" | "tag" | "aimer" | "commenter" | "snippetTag"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Utilisateur: {
        payload: Prisma.$UtilisateurPayload<ExtArgs>
        fields: Prisma.UtilisateurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UtilisateurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UtilisateurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          findFirst: {
            args: Prisma.UtilisateurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UtilisateurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          findMany: {
            args: Prisma.UtilisateurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          create: {
            args: Prisma.UtilisateurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          createMany: {
            args: Prisma.UtilisateurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UtilisateurCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          delete: {
            args: Prisma.UtilisateurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          update: {
            args: Prisma.UtilisateurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          deleteMany: {
            args: Prisma.UtilisateurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UtilisateurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UtilisateurUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>[]
          }
          upsert: {
            args: Prisma.UtilisateurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UtilisateurPayload>
          }
          aggregate: {
            args: Prisma.UtilisateurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUtilisateur>
          }
          groupBy: {
            args: Prisma.UtilisateurGroupByArgs<ExtArgs>
            result: $Utils.Optional<UtilisateurGroupByOutputType>[]
          }
          count: {
            args: Prisma.UtilisateurCountArgs<ExtArgs>
            result: $Utils.Optional<UtilisateurCountAggregateOutputType> | number
          }
        }
      }
      Snippet: {
        payload: Prisma.$SnippetPayload<ExtArgs>
        fields: Prisma.SnippetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SnippetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SnippetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          findFirst: {
            args: Prisma.SnippetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SnippetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          findMany: {
            args: Prisma.SnippetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>[]
          }
          create: {
            args: Prisma.SnippetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          createMany: {
            args: Prisma.SnippetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SnippetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>[]
          }
          delete: {
            args: Prisma.SnippetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          update: {
            args: Prisma.SnippetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          deleteMany: {
            args: Prisma.SnippetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SnippetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SnippetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>[]
          }
          upsert: {
            args: Prisma.SnippetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SnippetPayload>
          }
          aggregate: {
            args: Prisma.SnippetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSnippet>
          }
          groupBy: {
            args: Prisma.SnippetGroupByArgs<ExtArgs>
            result: $Utils.Optional<SnippetGroupByOutputType>[]
          }
          count: {
            args: Prisma.SnippetCountArgs<ExtArgs>
            result: $Utils.Optional<SnippetCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      aimer: {
        payload: Prisma.$aimerPayload<ExtArgs>
        fields: Prisma.aimerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.aimerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.aimerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload>
          }
          findFirst: {
            args: Prisma.aimerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.aimerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload>
          }
          findMany: {
            args: Prisma.aimerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload>[]
          }
          create: {
            args: Prisma.aimerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload>
          }
          createMany: {
            args: Prisma.aimerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.aimerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload>[]
          }
          delete: {
            args: Prisma.aimerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload>
          }
          update: {
            args: Prisma.aimerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload>
          }
          deleteMany: {
            args: Prisma.aimerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.aimerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.aimerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload>[]
          }
          upsert: {
            args: Prisma.aimerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$aimerPayload>
          }
          aggregate: {
            args: Prisma.AimerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAimer>
          }
          groupBy: {
            args: Prisma.aimerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AimerGroupByOutputType>[]
          }
          count: {
            args: Prisma.aimerCountArgs<ExtArgs>
            result: $Utils.Optional<AimerCountAggregateOutputType> | number
          }
        }
      }
      commenter: {
        payload: Prisma.$commenterPayload<ExtArgs>
        fields: Prisma.commenterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commenterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commenterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload>
          }
          findFirst: {
            args: Prisma.commenterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commenterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload>
          }
          findMany: {
            args: Prisma.commenterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload>[]
          }
          create: {
            args: Prisma.commenterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload>
          }
          createMany: {
            args: Prisma.commenterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.commenterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload>[]
          }
          delete: {
            args: Prisma.commenterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload>
          }
          update: {
            args: Prisma.commenterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload>
          }
          deleteMany: {
            args: Prisma.commenterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.commenterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.commenterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload>[]
          }
          upsert: {
            args: Prisma.commenterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commenterPayload>
          }
          aggregate: {
            args: Prisma.CommenterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommenter>
          }
          groupBy: {
            args: Prisma.commenterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommenterGroupByOutputType>[]
          }
          count: {
            args: Prisma.commenterCountArgs<ExtArgs>
            result: $Utils.Optional<CommenterCountAggregateOutputType> | number
          }
        }
      }
      snippetTag: {
        payload: Prisma.$snippetTagPayload<ExtArgs>
        fields: Prisma.snippetTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.snippetTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.snippetTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload>
          }
          findFirst: {
            args: Prisma.snippetTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.snippetTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload>
          }
          findMany: {
            args: Prisma.snippetTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload>[]
          }
          create: {
            args: Prisma.snippetTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload>
          }
          createMany: {
            args: Prisma.snippetTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.snippetTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload>[]
          }
          delete: {
            args: Prisma.snippetTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload>
          }
          update: {
            args: Prisma.snippetTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload>
          }
          deleteMany: {
            args: Prisma.snippetTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.snippetTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.snippetTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload>[]
          }
          upsert: {
            args: Prisma.snippetTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$snippetTagPayload>
          }
          aggregate: {
            args: Prisma.SnippetTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSnippetTag>
          }
          groupBy: {
            args: Prisma.snippetTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<SnippetTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.snippetTagCountArgs<ExtArgs>
            result: $Utils.Optional<SnippetTagCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    utilisateur?: UtilisateurOmit
    snippet?: SnippetOmit
    tag?: TagOmit
    aimer?: aimerOmit
    commenter?: commenterOmit
    snippetTag?: snippetTagOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UtilisateurCountOutputType
   */

  export type UtilisateurCountOutputType = {
    snippets: number
    aimer: number
    commenter: number
  }

  export type UtilisateurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snippets?: boolean | UtilisateurCountOutputTypeCountSnippetsArgs
    aimer?: boolean | UtilisateurCountOutputTypeCountAimerArgs
    commenter?: boolean | UtilisateurCountOutputTypeCountCommenterArgs
  }

  // Custom InputTypes
  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UtilisateurCountOutputType
     */
    select?: UtilisateurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountSnippetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnippetWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountAimerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aimerWhereInput
  }

  /**
   * UtilisateurCountOutputType without action
   */
  export type UtilisateurCountOutputTypeCountCommenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commenterWhereInput
  }


  /**
   * Count Type SnippetCountOutputType
   */

  export type SnippetCountOutputType = {
    aimer: number
    commenter: number
    snippetTag: number
  }

  export type SnippetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aimer?: boolean | SnippetCountOutputTypeCountAimerArgs
    commenter?: boolean | SnippetCountOutputTypeCountCommenterArgs
    snippetTag?: boolean | SnippetCountOutputTypeCountSnippetTagArgs
  }

  // Custom InputTypes
  /**
   * SnippetCountOutputType without action
   */
  export type SnippetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SnippetCountOutputType
     */
    select?: SnippetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SnippetCountOutputType without action
   */
  export type SnippetCountOutputTypeCountAimerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aimerWhereInput
  }

  /**
   * SnippetCountOutputType without action
   */
  export type SnippetCountOutputTypeCountCommenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commenterWhereInput
  }

  /**
   * SnippetCountOutputType without action
   */
  export type SnippetCountOutputTypeCountSnippetTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: snippetTagWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    snippetTag: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snippetTag?: boolean | TagCountOutputTypeCountSnippetTagArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountSnippetTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: snippetTagWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Utilisateur
   */

  export type AggregateUtilisateur = {
    _count: UtilisateurCountAggregateOutputType | null
    _avg: UtilisateurAvgAggregateOutputType | null
    _sum: UtilisateurSumAggregateOutputType | null
    _min: UtilisateurMinAggregateOutputType | null
    _max: UtilisateurMaxAggregateOutputType | null
  }

  export type UtilisateurAvgAggregateOutputType = {
    identifiant_utilisateur: number | null
  }

  export type UtilisateurSumAggregateOutputType = {
    identifiant_utilisateur: number | null
  }

  export type UtilisateurMinAggregateOutputType = {
    identifiant_utilisateur: number | null
    email: string | null
    motdepasse_hash: string | null
    creer_le: Date | null
  }

  export type UtilisateurMaxAggregateOutputType = {
    identifiant_utilisateur: number | null
    email: string | null
    motdepasse_hash: string | null
    creer_le: Date | null
  }

  export type UtilisateurCountAggregateOutputType = {
    identifiant_utilisateur: number
    email: number
    motdepasse_hash: number
    creer_le: number
    _all: number
  }


  export type UtilisateurAvgAggregateInputType = {
    identifiant_utilisateur?: true
  }

  export type UtilisateurSumAggregateInputType = {
    identifiant_utilisateur?: true
  }

  export type UtilisateurMinAggregateInputType = {
    identifiant_utilisateur?: true
    email?: true
    motdepasse_hash?: true
    creer_le?: true
  }

  export type UtilisateurMaxAggregateInputType = {
    identifiant_utilisateur?: true
    email?: true
    motdepasse_hash?: true
    creer_le?: true
  }

  export type UtilisateurCountAggregateInputType = {
    identifiant_utilisateur?: true
    email?: true
    motdepasse_hash?: true
    creer_le?: true
    _all?: true
  }

  export type UtilisateurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utilisateur to aggregate.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Utilisateurs
    **/
    _count?: true | UtilisateurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UtilisateurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UtilisateurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UtilisateurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UtilisateurMaxAggregateInputType
  }

  export type GetUtilisateurAggregateType<T extends UtilisateurAggregateArgs> = {
        [P in keyof T & keyof AggregateUtilisateur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUtilisateur[P]>
      : GetScalarType<T[P], AggregateUtilisateur[P]>
  }




  export type UtilisateurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UtilisateurWhereInput
    orderBy?: UtilisateurOrderByWithAggregationInput | UtilisateurOrderByWithAggregationInput[]
    by: UtilisateurScalarFieldEnum[] | UtilisateurScalarFieldEnum
    having?: UtilisateurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UtilisateurCountAggregateInputType | true
    _avg?: UtilisateurAvgAggregateInputType
    _sum?: UtilisateurSumAggregateInputType
    _min?: UtilisateurMinAggregateInputType
    _max?: UtilisateurMaxAggregateInputType
  }

  export type UtilisateurGroupByOutputType = {
    identifiant_utilisateur: number
    email: string
    motdepasse_hash: string
    creer_le: Date
    _count: UtilisateurCountAggregateOutputType | null
    _avg: UtilisateurAvgAggregateOutputType | null
    _sum: UtilisateurSumAggregateOutputType | null
    _min: UtilisateurMinAggregateOutputType | null
    _max: UtilisateurMaxAggregateOutputType | null
  }

  type GetUtilisateurGroupByPayload<T extends UtilisateurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UtilisateurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UtilisateurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UtilisateurGroupByOutputType[P]>
            : GetScalarType<T[P], UtilisateurGroupByOutputType[P]>
        }
      >
    >


  export type UtilisateurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_utilisateur?: boolean
    email?: boolean
    motdepasse_hash?: boolean
    creer_le?: boolean
    snippets?: boolean | Utilisateur$snippetsArgs<ExtArgs>
    aimer?: boolean | Utilisateur$aimerArgs<ExtArgs>
    commenter?: boolean | Utilisateur$commenterArgs<ExtArgs>
    _count?: boolean | UtilisateurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_utilisateur?: boolean
    email?: boolean
    motdepasse_hash?: boolean
    creer_le?: boolean
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_utilisateur?: boolean
    email?: boolean
    motdepasse_hash?: boolean
    creer_le?: boolean
  }, ExtArgs["result"]["utilisateur"]>

  export type UtilisateurSelectScalar = {
    identifiant_utilisateur?: boolean
    email?: boolean
    motdepasse_hash?: boolean
    creer_le?: boolean
  }

  export type UtilisateurOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifiant_utilisateur" | "email" | "motdepasse_hash" | "creer_le", ExtArgs["result"]["utilisateur"]>
  export type UtilisateurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snippets?: boolean | Utilisateur$snippetsArgs<ExtArgs>
    aimer?: boolean | Utilisateur$aimerArgs<ExtArgs>
    commenter?: boolean | Utilisateur$commenterArgs<ExtArgs>
    _count?: boolean | UtilisateurCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UtilisateurIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UtilisateurIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UtilisateurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Utilisateur"
    objects: {
      snippets: Prisma.$SnippetPayload<ExtArgs>[]
      aimer: Prisma.$aimerPayload<ExtArgs>[]
      commenter: Prisma.$commenterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      identifiant_utilisateur: number
      email: string
      motdepasse_hash: string
      creer_le: Date
    }, ExtArgs["result"]["utilisateur"]>
    composites: {}
  }

  type UtilisateurGetPayload<S extends boolean | null | undefined | UtilisateurDefaultArgs> = $Result.GetResult<Prisma.$UtilisateurPayload, S>

  type UtilisateurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UtilisateurFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UtilisateurCountAggregateInputType | true
    }

  export interface UtilisateurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Utilisateur'], meta: { name: 'Utilisateur' } }
    /**
     * Find zero or one Utilisateur that matches the filter.
     * @param {UtilisateurFindUniqueArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UtilisateurFindUniqueArgs>(args: SelectSubset<T, UtilisateurFindUniqueArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Utilisateur that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UtilisateurFindUniqueOrThrowArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UtilisateurFindUniqueOrThrowArgs>(args: SelectSubset<T, UtilisateurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Utilisateur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindFirstArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UtilisateurFindFirstArgs>(args?: SelectSubset<T, UtilisateurFindFirstArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Utilisateur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindFirstOrThrowArgs} args - Arguments to find a Utilisateur
     * @example
     * // Get one Utilisateur
     * const utilisateur = await prisma.utilisateur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UtilisateurFindFirstOrThrowArgs>(args?: SelectSubset<T, UtilisateurFindFirstOrThrowArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Utilisateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Utilisateurs
     * const utilisateurs = await prisma.utilisateur.findMany()
     * 
     * // Get first 10 Utilisateurs
     * const utilisateurs = await prisma.utilisateur.findMany({ take: 10 })
     * 
     * // Only select the `identifiant_utilisateur`
     * const utilisateurWithIdentifiant_utilisateurOnly = await prisma.utilisateur.findMany({ select: { identifiant_utilisateur: true } })
     * 
     */
    findMany<T extends UtilisateurFindManyArgs>(args?: SelectSubset<T, UtilisateurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Utilisateur.
     * @param {UtilisateurCreateArgs} args - Arguments to create a Utilisateur.
     * @example
     * // Create one Utilisateur
     * const Utilisateur = await prisma.utilisateur.create({
     *   data: {
     *     // ... data to create a Utilisateur
     *   }
     * })
     * 
     */
    create<T extends UtilisateurCreateArgs>(args: SelectSubset<T, UtilisateurCreateArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Utilisateurs.
     * @param {UtilisateurCreateManyArgs} args - Arguments to create many Utilisateurs.
     * @example
     * // Create many Utilisateurs
     * const utilisateur = await prisma.utilisateur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UtilisateurCreateManyArgs>(args?: SelectSubset<T, UtilisateurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Utilisateurs and returns the data saved in the database.
     * @param {UtilisateurCreateManyAndReturnArgs} args - Arguments to create many Utilisateurs.
     * @example
     * // Create many Utilisateurs
     * const utilisateur = await prisma.utilisateur.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Utilisateurs and only return the `identifiant_utilisateur`
     * const utilisateurWithIdentifiant_utilisateurOnly = await prisma.utilisateur.createManyAndReturn({
     *   select: { identifiant_utilisateur: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UtilisateurCreateManyAndReturnArgs>(args?: SelectSubset<T, UtilisateurCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Utilisateur.
     * @param {UtilisateurDeleteArgs} args - Arguments to delete one Utilisateur.
     * @example
     * // Delete one Utilisateur
     * const Utilisateur = await prisma.utilisateur.delete({
     *   where: {
     *     // ... filter to delete one Utilisateur
     *   }
     * })
     * 
     */
    delete<T extends UtilisateurDeleteArgs>(args: SelectSubset<T, UtilisateurDeleteArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Utilisateur.
     * @param {UtilisateurUpdateArgs} args - Arguments to update one Utilisateur.
     * @example
     * // Update one Utilisateur
     * const utilisateur = await prisma.utilisateur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UtilisateurUpdateArgs>(args: SelectSubset<T, UtilisateurUpdateArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Utilisateurs.
     * @param {UtilisateurDeleteManyArgs} args - Arguments to filter Utilisateurs to delete.
     * @example
     * // Delete a few Utilisateurs
     * const { count } = await prisma.utilisateur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UtilisateurDeleteManyArgs>(args?: SelectSubset<T, UtilisateurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Utilisateurs
     * const utilisateur = await prisma.utilisateur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UtilisateurUpdateManyArgs>(args: SelectSubset<T, UtilisateurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Utilisateurs and returns the data updated in the database.
     * @param {UtilisateurUpdateManyAndReturnArgs} args - Arguments to update many Utilisateurs.
     * @example
     * // Update many Utilisateurs
     * const utilisateur = await prisma.utilisateur.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Utilisateurs and only return the `identifiant_utilisateur`
     * const utilisateurWithIdentifiant_utilisateurOnly = await prisma.utilisateur.updateManyAndReturn({
     *   select: { identifiant_utilisateur: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UtilisateurUpdateManyAndReturnArgs>(args: SelectSubset<T, UtilisateurUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Utilisateur.
     * @param {UtilisateurUpsertArgs} args - Arguments to update or create a Utilisateur.
     * @example
     * // Update or create a Utilisateur
     * const utilisateur = await prisma.utilisateur.upsert({
     *   create: {
     *     // ... data to create a Utilisateur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Utilisateur we want to update
     *   }
     * })
     */
    upsert<T extends UtilisateurUpsertArgs>(args: SelectSubset<T, UtilisateurUpsertArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Utilisateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurCountArgs} args - Arguments to filter Utilisateurs to count.
     * @example
     * // Count the number of Utilisateurs
     * const count = await prisma.utilisateur.count({
     *   where: {
     *     // ... the filter for the Utilisateurs we want to count
     *   }
     * })
    **/
    count<T extends UtilisateurCountArgs>(
      args?: Subset<T, UtilisateurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UtilisateurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Utilisateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UtilisateurAggregateArgs>(args: Subset<T, UtilisateurAggregateArgs>): Prisma.PrismaPromise<GetUtilisateurAggregateType<T>>

    /**
     * Group by Utilisateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UtilisateurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UtilisateurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UtilisateurGroupByArgs['orderBy'] }
        : { orderBy?: UtilisateurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UtilisateurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUtilisateurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Utilisateur model
   */
  readonly fields: UtilisateurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Utilisateur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UtilisateurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    snippets<T extends Utilisateur$snippetsArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$snippetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    aimer<T extends Utilisateur$aimerArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$aimerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commenter<T extends Utilisateur$commenterArgs<ExtArgs> = {}>(args?: Subset<T, Utilisateur$commenterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Utilisateur model
   */
  interface UtilisateurFieldRefs {
    readonly identifiant_utilisateur: FieldRef<"Utilisateur", 'Int'>
    readonly email: FieldRef<"Utilisateur", 'String'>
    readonly motdepasse_hash: FieldRef<"Utilisateur", 'String'>
    readonly creer_le: FieldRef<"Utilisateur", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Utilisateur findUnique
   */
  export type UtilisateurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur findUniqueOrThrow
   */
  export type UtilisateurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur findFirst
   */
  export type UtilisateurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utilisateurs.
     */
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }

  /**
   * Utilisateur findFirstOrThrow
   */
  export type UtilisateurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateur to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Utilisateurs.
     */
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }

  /**
   * Utilisateur findMany
   */
  export type UtilisateurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter, which Utilisateurs to fetch.
     */
    where?: UtilisateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Utilisateurs to fetch.
     */
    orderBy?: UtilisateurOrderByWithRelationInput | UtilisateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Utilisateurs.
     */
    cursor?: UtilisateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Utilisateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Utilisateurs.
     */
    skip?: number
    distinct?: UtilisateurScalarFieldEnum | UtilisateurScalarFieldEnum[]
  }

  /**
   * Utilisateur create
   */
  export type UtilisateurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * The data needed to create a Utilisateur.
     */
    data: XOR<UtilisateurCreateInput, UtilisateurUncheckedCreateInput>
  }

  /**
   * Utilisateur createMany
   */
  export type UtilisateurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Utilisateurs.
     */
    data: UtilisateurCreateManyInput | UtilisateurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Utilisateur createManyAndReturn
   */
  export type UtilisateurCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * The data used to create many Utilisateurs.
     */
    data: UtilisateurCreateManyInput | UtilisateurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Utilisateur update
   */
  export type UtilisateurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * The data needed to update a Utilisateur.
     */
    data: XOR<UtilisateurUpdateInput, UtilisateurUncheckedUpdateInput>
    /**
     * Choose, which Utilisateur to update.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur updateMany
   */
  export type UtilisateurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Utilisateurs.
     */
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyInput>
    /**
     * Filter which Utilisateurs to update
     */
    where?: UtilisateurWhereInput
    /**
     * Limit how many Utilisateurs to update.
     */
    limit?: number
  }

  /**
   * Utilisateur updateManyAndReturn
   */
  export type UtilisateurUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * The data used to update Utilisateurs.
     */
    data: XOR<UtilisateurUpdateManyMutationInput, UtilisateurUncheckedUpdateManyInput>
    /**
     * Filter which Utilisateurs to update
     */
    where?: UtilisateurWhereInput
    /**
     * Limit how many Utilisateurs to update.
     */
    limit?: number
  }

  /**
   * Utilisateur upsert
   */
  export type UtilisateurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * The filter to search for the Utilisateur to update in case it exists.
     */
    where: UtilisateurWhereUniqueInput
    /**
     * In case the Utilisateur found by the `where` argument doesn't exist, create a new Utilisateur with this data.
     */
    create: XOR<UtilisateurCreateInput, UtilisateurUncheckedCreateInput>
    /**
     * In case the Utilisateur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UtilisateurUpdateInput, UtilisateurUncheckedUpdateInput>
  }

  /**
   * Utilisateur delete
   */
  export type UtilisateurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
    /**
     * Filter which Utilisateur to delete.
     */
    where: UtilisateurWhereUniqueInput
  }

  /**
   * Utilisateur deleteMany
   */
  export type UtilisateurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Utilisateurs to delete
     */
    where?: UtilisateurWhereInput
    /**
     * Limit how many Utilisateurs to delete.
     */
    limit?: number
  }

  /**
   * Utilisateur.snippets
   */
  export type Utilisateur$snippetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
    where?: SnippetWhereInput
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    cursor?: SnippetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnippetScalarFieldEnum | SnippetScalarFieldEnum[]
  }

  /**
   * Utilisateur.aimer
   */
  export type Utilisateur$aimerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    where?: aimerWhereInput
    orderBy?: aimerOrderByWithRelationInput | aimerOrderByWithRelationInput[]
    cursor?: aimerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AimerScalarFieldEnum | AimerScalarFieldEnum[]
  }

  /**
   * Utilisateur.commenter
   */
  export type Utilisateur$commenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    where?: commenterWhereInput
    orderBy?: commenterOrderByWithRelationInput | commenterOrderByWithRelationInput[]
    cursor?: commenterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommenterScalarFieldEnum | CommenterScalarFieldEnum[]
  }

  /**
   * Utilisateur without action
   */
  export type UtilisateurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Utilisateur
     */
    select?: UtilisateurSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Utilisateur
     */
    omit?: UtilisateurOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UtilisateurInclude<ExtArgs> | null
  }


  /**
   * Model Snippet
   */

  export type AggregateSnippet = {
    _count: SnippetCountAggregateOutputType | null
    _avg: SnippetAvgAggregateOutputType | null
    _sum: SnippetSumAggregateOutputType | null
    _min: SnippetMinAggregateOutputType | null
    _max: SnippetMaxAggregateOutputType | null
  }

  export type SnippetAvgAggregateOutputType = {
    identifiant_snippet: number | null
    identifiant_utilisateur: number | null
  }

  export type SnippetSumAggregateOutputType = {
    identifiant_snippet: number | null
    identifiant_utilisateur: number | null
  }

  export type SnippetMinAggregateOutputType = {
    identifiant_snippet: number | null
    titre: string | null
    code: string | null
    langage: string | null
    visibilite: string | null
    creer_le: Date | null
    identifiant_utilisateur: number | null
  }

  export type SnippetMaxAggregateOutputType = {
    identifiant_snippet: number | null
    titre: string | null
    code: string | null
    langage: string | null
    visibilite: string | null
    creer_le: Date | null
    identifiant_utilisateur: number | null
  }

  export type SnippetCountAggregateOutputType = {
    identifiant_snippet: number
    titre: number
    code: number
    langage: number
    visibilite: number
    creer_le: number
    identifiant_utilisateur: number
    _all: number
  }


  export type SnippetAvgAggregateInputType = {
    identifiant_snippet?: true
    identifiant_utilisateur?: true
  }

  export type SnippetSumAggregateInputType = {
    identifiant_snippet?: true
    identifiant_utilisateur?: true
  }

  export type SnippetMinAggregateInputType = {
    identifiant_snippet?: true
    titre?: true
    code?: true
    langage?: true
    visibilite?: true
    creer_le?: true
    identifiant_utilisateur?: true
  }

  export type SnippetMaxAggregateInputType = {
    identifiant_snippet?: true
    titre?: true
    code?: true
    langage?: true
    visibilite?: true
    creer_le?: true
    identifiant_utilisateur?: true
  }

  export type SnippetCountAggregateInputType = {
    identifiant_snippet?: true
    titre?: true
    code?: true
    langage?: true
    visibilite?: true
    creer_le?: true
    identifiant_utilisateur?: true
    _all?: true
  }

  export type SnippetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snippet to aggregate.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Snippets
    **/
    _count?: true | SnippetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SnippetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SnippetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SnippetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SnippetMaxAggregateInputType
  }

  export type GetSnippetAggregateType<T extends SnippetAggregateArgs> = {
        [P in keyof T & keyof AggregateSnippet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSnippet[P]>
      : GetScalarType<T[P], AggregateSnippet[P]>
  }




  export type SnippetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SnippetWhereInput
    orderBy?: SnippetOrderByWithAggregationInput | SnippetOrderByWithAggregationInput[]
    by: SnippetScalarFieldEnum[] | SnippetScalarFieldEnum
    having?: SnippetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SnippetCountAggregateInputType | true
    _avg?: SnippetAvgAggregateInputType
    _sum?: SnippetSumAggregateInputType
    _min?: SnippetMinAggregateInputType
    _max?: SnippetMaxAggregateInputType
  }

  export type SnippetGroupByOutputType = {
    identifiant_snippet: number
    titre: string | null
    code: string | null
    langage: string | null
    visibilite: string | null
    creer_le: Date
    identifiant_utilisateur: number
    _count: SnippetCountAggregateOutputType | null
    _avg: SnippetAvgAggregateOutputType | null
    _sum: SnippetSumAggregateOutputType | null
    _min: SnippetMinAggregateOutputType | null
    _max: SnippetMaxAggregateOutputType | null
  }

  type GetSnippetGroupByPayload<T extends SnippetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SnippetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SnippetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SnippetGroupByOutputType[P]>
            : GetScalarType<T[P], SnippetGroupByOutputType[P]>
        }
      >
    >


  export type SnippetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_snippet?: boolean
    titre?: boolean
    code?: boolean
    langage?: boolean
    visibilite?: boolean
    creer_le?: boolean
    identifiant_utilisateur?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    aimer?: boolean | Snippet$aimerArgs<ExtArgs>
    commenter?: boolean | Snippet$commenterArgs<ExtArgs>
    snippetTag?: boolean | Snippet$snippetTagArgs<ExtArgs>
    _count?: boolean | SnippetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["snippet"]>

  export type SnippetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_snippet?: boolean
    titre?: boolean
    code?: boolean
    langage?: boolean
    visibilite?: boolean
    creer_le?: boolean
    identifiant_utilisateur?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["snippet"]>

  export type SnippetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_snippet?: boolean
    titre?: boolean
    code?: boolean
    langage?: boolean
    visibilite?: boolean
    creer_le?: boolean
    identifiant_utilisateur?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["snippet"]>

  export type SnippetSelectScalar = {
    identifiant_snippet?: boolean
    titre?: boolean
    code?: boolean
    langage?: boolean
    visibilite?: boolean
    creer_le?: boolean
    identifiant_utilisateur?: boolean
  }

  export type SnippetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifiant_snippet" | "titre" | "code" | "langage" | "visibilite" | "creer_le" | "identifiant_utilisateur", ExtArgs["result"]["snippet"]>
  export type SnippetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    aimer?: boolean | Snippet$aimerArgs<ExtArgs>
    commenter?: boolean | Snippet$commenterArgs<ExtArgs>
    snippetTag?: boolean | Snippet$snippetTagArgs<ExtArgs>
    _count?: boolean | SnippetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SnippetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }
  export type SnippetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
  }

  export type $SnippetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Snippet"
    objects: {
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
      aimer: Prisma.$aimerPayload<ExtArgs>[]
      commenter: Prisma.$commenterPayload<ExtArgs>[]
      snippetTag: Prisma.$snippetTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      identifiant_snippet: number
      titre: string | null
      code: string | null
      langage: string | null
      visibilite: string | null
      creer_le: Date
      identifiant_utilisateur: number
    }, ExtArgs["result"]["snippet"]>
    composites: {}
  }

  type SnippetGetPayload<S extends boolean | null | undefined | SnippetDefaultArgs> = $Result.GetResult<Prisma.$SnippetPayload, S>

  type SnippetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SnippetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SnippetCountAggregateInputType | true
    }

  export interface SnippetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Snippet'], meta: { name: 'Snippet' } }
    /**
     * Find zero or one Snippet that matches the filter.
     * @param {SnippetFindUniqueArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SnippetFindUniqueArgs>(args: SelectSubset<T, SnippetFindUniqueArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Snippet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SnippetFindUniqueOrThrowArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SnippetFindUniqueOrThrowArgs>(args: SelectSubset<T, SnippetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Snippet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetFindFirstArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SnippetFindFirstArgs>(args?: SelectSubset<T, SnippetFindFirstArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Snippet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetFindFirstOrThrowArgs} args - Arguments to find a Snippet
     * @example
     * // Get one Snippet
     * const snippet = await prisma.snippet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SnippetFindFirstOrThrowArgs>(args?: SelectSubset<T, SnippetFindFirstOrThrowArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Snippets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Snippets
     * const snippets = await prisma.snippet.findMany()
     * 
     * // Get first 10 Snippets
     * const snippets = await prisma.snippet.findMany({ take: 10 })
     * 
     * // Only select the `identifiant_snippet`
     * const snippetWithIdentifiant_snippetOnly = await prisma.snippet.findMany({ select: { identifiant_snippet: true } })
     * 
     */
    findMany<T extends SnippetFindManyArgs>(args?: SelectSubset<T, SnippetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Snippet.
     * @param {SnippetCreateArgs} args - Arguments to create a Snippet.
     * @example
     * // Create one Snippet
     * const Snippet = await prisma.snippet.create({
     *   data: {
     *     // ... data to create a Snippet
     *   }
     * })
     * 
     */
    create<T extends SnippetCreateArgs>(args: SelectSubset<T, SnippetCreateArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Snippets.
     * @param {SnippetCreateManyArgs} args - Arguments to create many Snippets.
     * @example
     * // Create many Snippets
     * const snippet = await prisma.snippet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SnippetCreateManyArgs>(args?: SelectSubset<T, SnippetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Snippets and returns the data saved in the database.
     * @param {SnippetCreateManyAndReturnArgs} args - Arguments to create many Snippets.
     * @example
     * // Create many Snippets
     * const snippet = await prisma.snippet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Snippets and only return the `identifiant_snippet`
     * const snippetWithIdentifiant_snippetOnly = await prisma.snippet.createManyAndReturn({
     *   select: { identifiant_snippet: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SnippetCreateManyAndReturnArgs>(args?: SelectSubset<T, SnippetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Snippet.
     * @param {SnippetDeleteArgs} args - Arguments to delete one Snippet.
     * @example
     * // Delete one Snippet
     * const Snippet = await prisma.snippet.delete({
     *   where: {
     *     // ... filter to delete one Snippet
     *   }
     * })
     * 
     */
    delete<T extends SnippetDeleteArgs>(args: SelectSubset<T, SnippetDeleteArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Snippet.
     * @param {SnippetUpdateArgs} args - Arguments to update one Snippet.
     * @example
     * // Update one Snippet
     * const snippet = await prisma.snippet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SnippetUpdateArgs>(args: SelectSubset<T, SnippetUpdateArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Snippets.
     * @param {SnippetDeleteManyArgs} args - Arguments to filter Snippets to delete.
     * @example
     * // Delete a few Snippets
     * const { count } = await prisma.snippet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SnippetDeleteManyArgs>(args?: SelectSubset<T, SnippetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Snippets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Snippets
     * const snippet = await prisma.snippet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SnippetUpdateManyArgs>(args: SelectSubset<T, SnippetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Snippets and returns the data updated in the database.
     * @param {SnippetUpdateManyAndReturnArgs} args - Arguments to update many Snippets.
     * @example
     * // Update many Snippets
     * const snippet = await prisma.snippet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Snippets and only return the `identifiant_snippet`
     * const snippetWithIdentifiant_snippetOnly = await prisma.snippet.updateManyAndReturn({
     *   select: { identifiant_snippet: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SnippetUpdateManyAndReturnArgs>(args: SelectSubset<T, SnippetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Snippet.
     * @param {SnippetUpsertArgs} args - Arguments to update or create a Snippet.
     * @example
     * // Update or create a Snippet
     * const snippet = await prisma.snippet.upsert({
     *   create: {
     *     // ... data to create a Snippet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Snippet we want to update
     *   }
     * })
     */
    upsert<T extends SnippetUpsertArgs>(args: SelectSubset<T, SnippetUpsertArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Snippets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetCountArgs} args - Arguments to filter Snippets to count.
     * @example
     * // Count the number of Snippets
     * const count = await prisma.snippet.count({
     *   where: {
     *     // ... the filter for the Snippets we want to count
     *   }
     * })
    **/
    count<T extends SnippetCountArgs>(
      args?: Subset<T, SnippetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SnippetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Snippet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SnippetAggregateArgs>(args: Subset<T, SnippetAggregateArgs>): Prisma.PrismaPromise<GetSnippetAggregateType<T>>

    /**
     * Group by Snippet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SnippetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SnippetGroupByArgs['orderBy'] }
        : { orderBy?: SnippetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SnippetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSnippetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Snippet model
   */
  readonly fields: SnippetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Snippet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SnippetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    aimer<T extends Snippet$aimerArgs<ExtArgs> = {}>(args?: Subset<T, Snippet$aimerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commenter<T extends Snippet$commenterArgs<ExtArgs> = {}>(args?: Subset<T, Snippet$commenterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    snippetTag<T extends Snippet$snippetTagArgs<ExtArgs> = {}>(args?: Subset<T, Snippet$snippetTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Snippet model
   */
  interface SnippetFieldRefs {
    readonly identifiant_snippet: FieldRef<"Snippet", 'Int'>
    readonly titre: FieldRef<"Snippet", 'String'>
    readonly code: FieldRef<"Snippet", 'String'>
    readonly langage: FieldRef<"Snippet", 'String'>
    readonly visibilite: FieldRef<"Snippet", 'String'>
    readonly creer_le: FieldRef<"Snippet", 'DateTime'>
    readonly identifiant_utilisateur: FieldRef<"Snippet", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Snippet findUnique
   */
  export type SnippetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet findUniqueOrThrow
   */
  export type SnippetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet findFirst
   */
  export type SnippetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snippets.
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snippets.
     */
    distinct?: SnippetScalarFieldEnum | SnippetScalarFieldEnum[]
  }

  /**
   * Snippet findFirstOrThrow
   */
  export type SnippetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
    /**
     * Filter, which Snippet to fetch.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Snippets.
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Snippets.
     */
    distinct?: SnippetScalarFieldEnum | SnippetScalarFieldEnum[]
  }

  /**
   * Snippet findMany
   */
  export type SnippetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
    /**
     * Filter, which Snippets to fetch.
     */
    where?: SnippetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Snippets to fetch.
     */
    orderBy?: SnippetOrderByWithRelationInput | SnippetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Snippets.
     */
    cursor?: SnippetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Snippets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Snippets.
     */
    skip?: number
    distinct?: SnippetScalarFieldEnum | SnippetScalarFieldEnum[]
  }

  /**
   * Snippet create
   */
  export type SnippetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
    /**
     * The data needed to create a Snippet.
     */
    data: XOR<SnippetCreateInput, SnippetUncheckedCreateInput>
  }

  /**
   * Snippet createMany
   */
  export type SnippetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Snippets.
     */
    data: SnippetCreateManyInput | SnippetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Snippet createManyAndReturn
   */
  export type SnippetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * The data used to create many Snippets.
     */
    data: SnippetCreateManyInput | SnippetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Snippet update
   */
  export type SnippetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
    /**
     * The data needed to update a Snippet.
     */
    data: XOR<SnippetUpdateInput, SnippetUncheckedUpdateInput>
    /**
     * Choose, which Snippet to update.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet updateMany
   */
  export type SnippetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Snippets.
     */
    data: XOR<SnippetUpdateManyMutationInput, SnippetUncheckedUpdateManyInput>
    /**
     * Filter which Snippets to update
     */
    where?: SnippetWhereInput
    /**
     * Limit how many Snippets to update.
     */
    limit?: number
  }

  /**
   * Snippet updateManyAndReturn
   */
  export type SnippetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * The data used to update Snippets.
     */
    data: XOR<SnippetUpdateManyMutationInput, SnippetUncheckedUpdateManyInput>
    /**
     * Filter which Snippets to update
     */
    where?: SnippetWhereInput
    /**
     * Limit how many Snippets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Snippet upsert
   */
  export type SnippetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
    /**
     * The filter to search for the Snippet to update in case it exists.
     */
    where: SnippetWhereUniqueInput
    /**
     * In case the Snippet found by the `where` argument doesn't exist, create a new Snippet with this data.
     */
    create: XOR<SnippetCreateInput, SnippetUncheckedCreateInput>
    /**
     * In case the Snippet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SnippetUpdateInput, SnippetUncheckedUpdateInput>
  }

  /**
   * Snippet delete
   */
  export type SnippetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
    /**
     * Filter which Snippet to delete.
     */
    where: SnippetWhereUniqueInput
  }

  /**
   * Snippet deleteMany
   */
  export type SnippetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Snippets to delete
     */
    where?: SnippetWhereInput
    /**
     * Limit how many Snippets to delete.
     */
    limit?: number
  }

  /**
   * Snippet.aimer
   */
  export type Snippet$aimerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    where?: aimerWhereInput
    orderBy?: aimerOrderByWithRelationInput | aimerOrderByWithRelationInput[]
    cursor?: aimerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AimerScalarFieldEnum | AimerScalarFieldEnum[]
  }

  /**
   * Snippet.commenter
   */
  export type Snippet$commenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    where?: commenterWhereInput
    orderBy?: commenterOrderByWithRelationInput | commenterOrderByWithRelationInput[]
    cursor?: commenterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommenterScalarFieldEnum | CommenterScalarFieldEnum[]
  }

  /**
   * Snippet.snippetTag
   */
  export type Snippet$snippetTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    where?: snippetTagWhereInput
    orderBy?: snippetTagOrderByWithRelationInput | snippetTagOrderByWithRelationInput[]
    cursor?: snippetTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnippetTagScalarFieldEnum | SnippetTagScalarFieldEnum[]
  }

  /**
   * Snippet without action
   */
  export type SnippetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Snippet
     */
    select?: SnippetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Snippet
     */
    omit?: SnippetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SnippetInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    identifiant_tag: number | null
  }

  export type TagSumAggregateOutputType = {
    identifiant_tag: number | null
  }

  export type TagMinAggregateOutputType = {
    identifiant_tag: number | null
    name: string | null
  }

  export type TagMaxAggregateOutputType = {
    identifiant_tag: number | null
    name: string | null
  }

  export type TagCountAggregateOutputType = {
    identifiant_tag: number
    name: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    identifiant_tag?: true
  }

  export type TagSumAggregateInputType = {
    identifiant_tag?: true
  }

  export type TagMinAggregateInputType = {
    identifiant_tag?: true
    name?: true
  }

  export type TagMaxAggregateInputType = {
    identifiant_tag?: true
    name?: true
  }

  export type TagCountAggregateInputType = {
    identifiant_tag?: true
    name?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    identifiant_tag: number
    name: string
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_tag?: boolean
    name?: boolean
    snippetTag?: boolean | Tag$snippetTagArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_tag?: boolean
    name?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_tag?: boolean
    name?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    identifiant_tag?: boolean
    name?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifiant_tag" | "name", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snippetTag?: boolean | Tag$snippetTagArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      snippetTag: Prisma.$snippetTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      identifiant_tag: number
      name: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `identifiant_tag`
     * const tagWithIdentifiant_tagOnly = await prisma.tag.findMany({ select: { identifiant_tag: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `identifiant_tag`
     * const tagWithIdentifiant_tagOnly = await prisma.tag.createManyAndReturn({
     *   select: { identifiant_tag: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `identifiant_tag`
     * const tagWithIdentifiant_tagOnly = await prisma.tag.updateManyAndReturn({
     *   select: { identifiant_tag: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    snippetTag<T extends Tag$snippetTagArgs<ExtArgs> = {}>(args?: Subset<T, Tag$snippetTagArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly identifiant_tag: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.snippetTag
   */
  export type Tag$snippetTagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    where?: snippetTagWhereInput
    orderBy?: snippetTagOrderByWithRelationInput | snippetTagOrderByWithRelationInput[]
    cursor?: snippetTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SnippetTagScalarFieldEnum | SnippetTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model aimer
   */

  export type AggregateAimer = {
    _count: AimerCountAggregateOutputType | null
    _avg: AimerAvgAggregateOutputType | null
    _sum: AimerSumAggregateOutputType | null
    _min: AimerMinAggregateOutputType | null
    _max: AimerMaxAggregateOutputType | null
  }

  export type AimerAvgAggregateOutputType = {
    identifiant_utilisateur: number | null
    identifiant_snippet: number | null
  }

  export type AimerSumAggregateOutputType = {
    identifiant_utilisateur: number | null
    identifiant_snippet: number | null
  }

  export type AimerMinAggregateOutputType = {
    identifiant_utilisateur: number | null
    identifiant_snippet: number | null
  }

  export type AimerMaxAggregateOutputType = {
    identifiant_utilisateur: number | null
    identifiant_snippet: number | null
  }

  export type AimerCountAggregateOutputType = {
    identifiant_utilisateur: number
    identifiant_snippet: number
    _all: number
  }


  export type AimerAvgAggregateInputType = {
    identifiant_utilisateur?: true
    identifiant_snippet?: true
  }

  export type AimerSumAggregateInputType = {
    identifiant_utilisateur?: true
    identifiant_snippet?: true
  }

  export type AimerMinAggregateInputType = {
    identifiant_utilisateur?: true
    identifiant_snippet?: true
  }

  export type AimerMaxAggregateInputType = {
    identifiant_utilisateur?: true
    identifiant_snippet?: true
  }

  export type AimerCountAggregateInputType = {
    identifiant_utilisateur?: true
    identifiant_snippet?: true
    _all?: true
  }

  export type AimerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aimer to aggregate.
     */
    where?: aimerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aimers to fetch.
     */
    orderBy?: aimerOrderByWithRelationInput | aimerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: aimerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aimers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aimers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned aimers
    **/
    _count?: true | AimerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AimerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AimerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AimerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AimerMaxAggregateInputType
  }

  export type GetAimerAggregateType<T extends AimerAggregateArgs> = {
        [P in keyof T & keyof AggregateAimer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAimer[P]>
      : GetScalarType<T[P], AggregateAimer[P]>
  }




  export type aimerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: aimerWhereInput
    orderBy?: aimerOrderByWithAggregationInput | aimerOrderByWithAggregationInput[]
    by: AimerScalarFieldEnum[] | AimerScalarFieldEnum
    having?: aimerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AimerCountAggregateInputType | true
    _avg?: AimerAvgAggregateInputType
    _sum?: AimerSumAggregateInputType
    _min?: AimerMinAggregateInputType
    _max?: AimerMaxAggregateInputType
  }

  export type AimerGroupByOutputType = {
    identifiant_utilisateur: number
    identifiant_snippet: number
    _count: AimerCountAggregateOutputType | null
    _avg: AimerAvgAggregateOutputType | null
    _sum: AimerSumAggregateOutputType | null
    _min: AimerMinAggregateOutputType | null
    _max: AimerMaxAggregateOutputType | null
  }

  type GetAimerGroupByPayload<T extends aimerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AimerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AimerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AimerGroupByOutputType[P]>
            : GetScalarType<T[P], AimerGroupByOutputType[P]>
        }
      >
    >


  export type aimerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_utilisateur?: boolean
    identifiant_snippet?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aimer"]>

  export type aimerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_utilisateur?: boolean
    identifiant_snippet?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aimer"]>

  export type aimerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_utilisateur?: boolean
    identifiant_snippet?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aimer"]>

  export type aimerSelectScalar = {
    identifiant_utilisateur?: boolean
    identifiant_snippet?: boolean
  }

  export type aimerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifiant_utilisateur" | "identifiant_snippet", ExtArgs["result"]["aimer"]>
  export type aimerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }
  export type aimerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }
  export type aimerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }

  export type $aimerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "aimer"
    objects: {
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
      snippet: Prisma.$SnippetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      identifiant_utilisateur: number
      identifiant_snippet: number
    }, ExtArgs["result"]["aimer"]>
    composites: {}
  }

  type aimerGetPayload<S extends boolean | null | undefined | aimerDefaultArgs> = $Result.GetResult<Prisma.$aimerPayload, S>

  type aimerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<aimerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AimerCountAggregateInputType | true
    }

  export interface aimerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['aimer'], meta: { name: 'aimer' } }
    /**
     * Find zero or one Aimer that matches the filter.
     * @param {aimerFindUniqueArgs} args - Arguments to find a Aimer
     * @example
     * // Get one Aimer
     * const aimer = await prisma.aimer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends aimerFindUniqueArgs>(args: SelectSubset<T, aimerFindUniqueArgs<ExtArgs>>): Prisma__aimerClient<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Aimer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {aimerFindUniqueOrThrowArgs} args - Arguments to find a Aimer
     * @example
     * // Get one Aimer
     * const aimer = await prisma.aimer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends aimerFindUniqueOrThrowArgs>(args: SelectSubset<T, aimerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__aimerClient<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aimer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aimerFindFirstArgs} args - Arguments to find a Aimer
     * @example
     * // Get one Aimer
     * const aimer = await prisma.aimer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends aimerFindFirstArgs>(args?: SelectSubset<T, aimerFindFirstArgs<ExtArgs>>): Prisma__aimerClient<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Aimer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aimerFindFirstOrThrowArgs} args - Arguments to find a Aimer
     * @example
     * // Get one Aimer
     * const aimer = await prisma.aimer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends aimerFindFirstOrThrowArgs>(args?: SelectSubset<T, aimerFindFirstOrThrowArgs<ExtArgs>>): Prisma__aimerClient<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Aimers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aimerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Aimers
     * const aimers = await prisma.aimer.findMany()
     * 
     * // Get first 10 Aimers
     * const aimers = await prisma.aimer.findMany({ take: 10 })
     * 
     * // Only select the `identifiant_utilisateur`
     * const aimerWithIdentifiant_utilisateurOnly = await prisma.aimer.findMany({ select: { identifiant_utilisateur: true } })
     * 
     */
    findMany<T extends aimerFindManyArgs>(args?: SelectSubset<T, aimerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Aimer.
     * @param {aimerCreateArgs} args - Arguments to create a Aimer.
     * @example
     * // Create one Aimer
     * const Aimer = await prisma.aimer.create({
     *   data: {
     *     // ... data to create a Aimer
     *   }
     * })
     * 
     */
    create<T extends aimerCreateArgs>(args: SelectSubset<T, aimerCreateArgs<ExtArgs>>): Prisma__aimerClient<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Aimers.
     * @param {aimerCreateManyArgs} args - Arguments to create many Aimers.
     * @example
     * // Create many Aimers
     * const aimer = await prisma.aimer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends aimerCreateManyArgs>(args?: SelectSubset<T, aimerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Aimers and returns the data saved in the database.
     * @param {aimerCreateManyAndReturnArgs} args - Arguments to create many Aimers.
     * @example
     * // Create many Aimers
     * const aimer = await prisma.aimer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Aimers and only return the `identifiant_utilisateur`
     * const aimerWithIdentifiant_utilisateurOnly = await prisma.aimer.createManyAndReturn({
     *   select: { identifiant_utilisateur: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends aimerCreateManyAndReturnArgs>(args?: SelectSubset<T, aimerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Aimer.
     * @param {aimerDeleteArgs} args - Arguments to delete one Aimer.
     * @example
     * // Delete one Aimer
     * const Aimer = await prisma.aimer.delete({
     *   where: {
     *     // ... filter to delete one Aimer
     *   }
     * })
     * 
     */
    delete<T extends aimerDeleteArgs>(args: SelectSubset<T, aimerDeleteArgs<ExtArgs>>): Prisma__aimerClient<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Aimer.
     * @param {aimerUpdateArgs} args - Arguments to update one Aimer.
     * @example
     * // Update one Aimer
     * const aimer = await prisma.aimer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends aimerUpdateArgs>(args: SelectSubset<T, aimerUpdateArgs<ExtArgs>>): Prisma__aimerClient<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Aimers.
     * @param {aimerDeleteManyArgs} args - Arguments to filter Aimers to delete.
     * @example
     * // Delete a few Aimers
     * const { count } = await prisma.aimer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends aimerDeleteManyArgs>(args?: SelectSubset<T, aimerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aimers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aimerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Aimers
     * const aimer = await prisma.aimer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends aimerUpdateManyArgs>(args: SelectSubset<T, aimerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Aimers and returns the data updated in the database.
     * @param {aimerUpdateManyAndReturnArgs} args - Arguments to update many Aimers.
     * @example
     * // Update many Aimers
     * const aimer = await prisma.aimer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Aimers and only return the `identifiant_utilisateur`
     * const aimerWithIdentifiant_utilisateurOnly = await prisma.aimer.updateManyAndReturn({
     *   select: { identifiant_utilisateur: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends aimerUpdateManyAndReturnArgs>(args: SelectSubset<T, aimerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Aimer.
     * @param {aimerUpsertArgs} args - Arguments to update or create a Aimer.
     * @example
     * // Update or create a Aimer
     * const aimer = await prisma.aimer.upsert({
     *   create: {
     *     // ... data to create a Aimer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Aimer we want to update
     *   }
     * })
     */
    upsert<T extends aimerUpsertArgs>(args: SelectSubset<T, aimerUpsertArgs<ExtArgs>>): Prisma__aimerClient<$Result.GetResult<Prisma.$aimerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Aimers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aimerCountArgs} args - Arguments to filter Aimers to count.
     * @example
     * // Count the number of Aimers
     * const count = await prisma.aimer.count({
     *   where: {
     *     // ... the filter for the Aimers we want to count
     *   }
     * })
    **/
    count<T extends aimerCountArgs>(
      args?: Subset<T, aimerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AimerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Aimer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AimerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AimerAggregateArgs>(args: Subset<T, AimerAggregateArgs>): Prisma.PrismaPromise<GetAimerAggregateType<T>>

    /**
     * Group by Aimer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {aimerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends aimerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: aimerGroupByArgs['orderBy'] }
        : { orderBy?: aimerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, aimerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAimerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the aimer model
   */
  readonly fields: aimerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for aimer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__aimerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    snippet<T extends SnippetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SnippetDefaultArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the aimer model
   */
  interface aimerFieldRefs {
    readonly identifiant_utilisateur: FieldRef<"aimer", 'Int'>
    readonly identifiant_snippet: FieldRef<"aimer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * aimer findUnique
   */
  export type aimerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    /**
     * Filter, which aimer to fetch.
     */
    where: aimerWhereUniqueInput
  }

  /**
   * aimer findUniqueOrThrow
   */
  export type aimerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    /**
     * Filter, which aimer to fetch.
     */
    where: aimerWhereUniqueInput
  }

  /**
   * aimer findFirst
   */
  export type aimerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    /**
     * Filter, which aimer to fetch.
     */
    where?: aimerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aimers to fetch.
     */
    orderBy?: aimerOrderByWithRelationInput | aimerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aimers.
     */
    cursor?: aimerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aimers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aimers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aimers.
     */
    distinct?: AimerScalarFieldEnum | AimerScalarFieldEnum[]
  }

  /**
   * aimer findFirstOrThrow
   */
  export type aimerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    /**
     * Filter, which aimer to fetch.
     */
    where?: aimerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aimers to fetch.
     */
    orderBy?: aimerOrderByWithRelationInput | aimerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for aimers.
     */
    cursor?: aimerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aimers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aimers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of aimers.
     */
    distinct?: AimerScalarFieldEnum | AimerScalarFieldEnum[]
  }

  /**
   * aimer findMany
   */
  export type aimerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    /**
     * Filter, which aimers to fetch.
     */
    where?: aimerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of aimers to fetch.
     */
    orderBy?: aimerOrderByWithRelationInput | aimerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing aimers.
     */
    cursor?: aimerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` aimers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` aimers.
     */
    skip?: number
    distinct?: AimerScalarFieldEnum | AimerScalarFieldEnum[]
  }

  /**
   * aimer create
   */
  export type aimerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    /**
     * The data needed to create a aimer.
     */
    data: XOR<aimerCreateInput, aimerUncheckedCreateInput>
  }

  /**
   * aimer createMany
   */
  export type aimerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many aimers.
     */
    data: aimerCreateManyInput | aimerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * aimer createManyAndReturn
   */
  export type aimerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * The data used to create many aimers.
     */
    data: aimerCreateManyInput | aimerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * aimer update
   */
  export type aimerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    /**
     * The data needed to update a aimer.
     */
    data: XOR<aimerUpdateInput, aimerUncheckedUpdateInput>
    /**
     * Choose, which aimer to update.
     */
    where: aimerWhereUniqueInput
  }

  /**
   * aimer updateMany
   */
  export type aimerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update aimers.
     */
    data: XOR<aimerUpdateManyMutationInput, aimerUncheckedUpdateManyInput>
    /**
     * Filter which aimers to update
     */
    where?: aimerWhereInput
    /**
     * Limit how many aimers to update.
     */
    limit?: number
  }

  /**
   * aimer updateManyAndReturn
   */
  export type aimerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * The data used to update aimers.
     */
    data: XOR<aimerUpdateManyMutationInput, aimerUncheckedUpdateManyInput>
    /**
     * Filter which aimers to update
     */
    where?: aimerWhereInput
    /**
     * Limit how many aimers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * aimer upsert
   */
  export type aimerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    /**
     * The filter to search for the aimer to update in case it exists.
     */
    where: aimerWhereUniqueInput
    /**
     * In case the aimer found by the `where` argument doesn't exist, create a new aimer with this data.
     */
    create: XOR<aimerCreateInput, aimerUncheckedCreateInput>
    /**
     * In case the aimer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<aimerUpdateInput, aimerUncheckedUpdateInput>
  }

  /**
   * aimer delete
   */
  export type aimerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
    /**
     * Filter which aimer to delete.
     */
    where: aimerWhereUniqueInput
  }

  /**
   * aimer deleteMany
   */
  export type aimerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which aimers to delete
     */
    where?: aimerWhereInput
    /**
     * Limit how many aimers to delete.
     */
    limit?: number
  }

  /**
   * aimer without action
   */
  export type aimerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the aimer
     */
    select?: aimerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the aimer
     */
    omit?: aimerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: aimerInclude<ExtArgs> | null
  }


  /**
   * Model commenter
   */

  export type AggregateCommenter = {
    _count: CommenterCountAggregateOutputType | null
    _avg: CommenterAvgAggregateOutputType | null
    _sum: CommenterSumAggregateOutputType | null
    _min: CommenterMinAggregateOutputType | null
    _max: CommenterMaxAggregateOutputType | null
  }

  export type CommenterAvgAggregateOutputType = {
    identifiant_utilisateur: number | null
    identifiant_snippet: number | null
  }

  export type CommenterSumAggregateOutputType = {
    identifiant_utilisateur: number | null
    identifiant_snippet: number | null
  }

  export type CommenterMinAggregateOutputType = {
    identifiant_utilisateur: number | null
    identifiant_snippet: number | null
    date_: Date | null
    texte: string | null
  }

  export type CommenterMaxAggregateOutputType = {
    identifiant_utilisateur: number | null
    identifiant_snippet: number | null
    date_: Date | null
    texte: string | null
  }

  export type CommenterCountAggregateOutputType = {
    identifiant_utilisateur: number
    identifiant_snippet: number
    date_: number
    texte: number
    _all: number
  }


  export type CommenterAvgAggregateInputType = {
    identifiant_utilisateur?: true
    identifiant_snippet?: true
  }

  export type CommenterSumAggregateInputType = {
    identifiant_utilisateur?: true
    identifiant_snippet?: true
  }

  export type CommenterMinAggregateInputType = {
    identifiant_utilisateur?: true
    identifiant_snippet?: true
    date_?: true
    texte?: true
  }

  export type CommenterMaxAggregateInputType = {
    identifiant_utilisateur?: true
    identifiant_snippet?: true
    date_?: true
    texte?: true
  }

  export type CommenterCountAggregateInputType = {
    identifiant_utilisateur?: true
    identifiant_snippet?: true
    date_?: true
    texte?: true
    _all?: true
  }

  export type CommenterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which commenter to aggregate.
     */
    where?: commenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commenters to fetch.
     */
    orderBy?: commenterOrderByWithRelationInput | commenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned commenters
    **/
    _count?: true | CommenterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommenterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommenterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommenterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommenterMaxAggregateInputType
  }

  export type GetCommenterAggregateType<T extends CommenterAggregateArgs> = {
        [P in keyof T & keyof AggregateCommenter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommenter[P]>
      : GetScalarType<T[P], AggregateCommenter[P]>
  }




  export type commenterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commenterWhereInput
    orderBy?: commenterOrderByWithAggregationInput | commenterOrderByWithAggregationInput[]
    by: CommenterScalarFieldEnum[] | CommenterScalarFieldEnum
    having?: commenterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommenterCountAggregateInputType | true
    _avg?: CommenterAvgAggregateInputType
    _sum?: CommenterSumAggregateInputType
    _min?: CommenterMinAggregateInputType
    _max?: CommenterMaxAggregateInputType
  }

  export type CommenterGroupByOutputType = {
    identifiant_utilisateur: number
    identifiant_snippet: number
    date_: Date
    texte: string | null
    _count: CommenterCountAggregateOutputType | null
    _avg: CommenterAvgAggregateOutputType | null
    _sum: CommenterSumAggregateOutputType | null
    _min: CommenterMinAggregateOutputType | null
    _max: CommenterMaxAggregateOutputType | null
  }

  type GetCommenterGroupByPayload<T extends commenterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommenterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommenterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommenterGroupByOutputType[P]>
            : GetScalarType<T[P], CommenterGroupByOutputType[P]>
        }
      >
    >


  export type commenterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_utilisateur?: boolean
    identifiant_snippet?: boolean
    date_?: boolean
    texte?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commenter"]>

  export type commenterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_utilisateur?: boolean
    identifiant_snippet?: boolean
    date_?: boolean
    texte?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commenter"]>

  export type commenterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifiant_utilisateur?: boolean
    identifiant_snippet?: boolean
    date_?: boolean
    texte?: boolean
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commenter"]>

  export type commenterSelectScalar = {
    identifiant_utilisateur?: boolean
    identifiant_snippet?: boolean
    date_?: boolean
    texte?: boolean
  }

  export type commenterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifiant_utilisateur" | "identifiant_snippet" | "date_" | "texte", ExtArgs["result"]["commenter"]>
  export type commenterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }
  export type commenterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }
  export type commenterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    utilisateur?: boolean | UtilisateurDefaultArgs<ExtArgs>
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
  }

  export type $commenterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "commenter"
    objects: {
      utilisateur: Prisma.$UtilisateurPayload<ExtArgs>
      snippet: Prisma.$SnippetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      identifiant_utilisateur: number
      identifiant_snippet: number
      date_: Date
      texte: string | null
    }, ExtArgs["result"]["commenter"]>
    composites: {}
  }

  type commenterGetPayload<S extends boolean | null | undefined | commenterDefaultArgs> = $Result.GetResult<Prisma.$commenterPayload, S>

  type commenterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<commenterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommenterCountAggregateInputType | true
    }

  export interface commenterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['commenter'], meta: { name: 'commenter' } }
    /**
     * Find zero or one Commenter that matches the filter.
     * @param {commenterFindUniqueArgs} args - Arguments to find a Commenter
     * @example
     * // Get one Commenter
     * const commenter = await prisma.commenter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends commenterFindUniqueArgs>(args: SelectSubset<T, commenterFindUniqueArgs<ExtArgs>>): Prisma__commenterClient<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Commenter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {commenterFindUniqueOrThrowArgs} args - Arguments to find a Commenter
     * @example
     * // Get one Commenter
     * const commenter = await prisma.commenter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends commenterFindUniqueOrThrowArgs>(args: SelectSubset<T, commenterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commenterClient<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Commenter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commenterFindFirstArgs} args - Arguments to find a Commenter
     * @example
     * // Get one Commenter
     * const commenter = await prisma.commenter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends commenterFindFirstArgs>(args?: SelectSubset<T, commenterFindFirstArgs<ExtArgs>>): Prisma__commenterClient<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Commenter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commenterFindFirstOrThrowArgs} args - Arguments to find a Commenter
     * @example
     * // Get one Commenter
     * const commenter = await prisma.commenter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends commenterFindFirstOrThrowArgs>(args?: SelectSubset<T, commenterFindFirstOrThrowArgs<ExtArgs>>): Prisma__commenterClient<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Commenters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commenterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commenters
     * const commenters = await prisma.commenter.findMany()
     * 
     * // Get first 10 Commenters
     * const commenters = await prisma.commenter.findMany({ take: 10 })
     * 
     * // Only select the `identifiant_utilisateur`
     * const commenterWithIdentifiant_utilisateurOnly = await prisma.commenter.findMany({ select: { identifiant_utilisateur: true } })
     * 
     */
    findMany<T extends commenterFindManyArgs>(args?: SelectSubset<T, commenterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Commenter.
     * @param {commenterCreateArgs} args - Arguments to create a Commenter.
     * @example
     * // Create one Commenter
     * const Commenter = await prisma.commenter.create({
     *   data: {
     *     // ... data to create a Commenter
     *   }
     * })
     * 
     */
    create<T extends commenterCreateArgs>(args: SelectSubset<T, commenterCreateArgs<ExtArgs>>): Prisma__commenterClient<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Commenters.
     * @param {commenterCreateManyArgs} args - Arguments to create many Commenters.
     * @example
     * // Create many Commenters
     * const commenter = await prisma.commenter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends commenterCreateManyArgs>(args?: SelectSubset<T, commenterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commenters and returns the data saved in the database.
     * @param {commenterCreateManyAndReturnArgs} args - Arguments to create many Commenters.
     * @example
     * // Create many Commenters
     * const commenter = await prisma.commenter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commenters and only return the `identifiant_utilisateur`
     * const commenterWithIdentifiant_utilisateurOnly = await prisma.commenter.createManyAndReturn({
     *   select: { identifiant_utilisateur: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends commenterCreateManyAndReturnArgs>(args?: SelectSubset<T, commenterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Commenter.
     * @param {commenterDeleteArgs} args - Arguments to delete one Commenter.
     * @example
     * // Delete one Commenter
     * const Commenter = await prisma.commenter.delete({
     *   where: {
     *     // ... filter to delete one Commenter
     *   }
     * })
     * 
     */
    delete<T extends commenterDeleteArgs>(args: SelectSubset<T, commenterDeleteArgs<ExtArgs>>): Prisma__commenterClient<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Commenter.
     * @param {commenterUpdateArgs} args - Arguments to update one Commenter.
     * @example
     * // Update one Commenter
     * const commenter = await prisma.commenter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends commenterUpdateArgs>(args: SelectSubset<T, commenterUpdateArgs<ExtArgs>>): Prisma__commenterClient<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Commenters.
     * @param {commenterDeleteManyArgs} args - Arguments to filter Commenters to delete.
     * @example
     * // Delete a few Commenters
     * const { count } = await prisma.commenter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends commenterDeleteManyArgs>(args?: SelectSubset<T, commenterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commenterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commenters
     * const commenter = await prisma.commenter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends commenterUpdateManyArgs>(args: SelectSubset<T, commenterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commenters and returns the data updated in the database.
     * @param {commenterUpdateManyAndReturnArgs} args - Arguments to update many Commenters.
     * @example
     * // Update many Commenters
     * const commenter = await prisma.commenter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Commenters and only return the `identifiant_utilisateur`
     * const commenterWithIdentifiant_utilisateurOnly = await prisma.commenter.updateManyAndReturn({
     *   select: { identifiant_utilisateur: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends commenterUpdateManyAndReturnArgs>(args: SelectSubset<T, commenterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Commenter.
     * @param {commenterUpsertArgs} args - Arguments to update or create a Commenter.
     * @example
     * // Update or create a Commenter
     * const commenter = await prisma.commenter.upsert({
     *   create: {
     *     // ... data to create a Commenter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commenter we want to update
     *   }
     * })
     */
    upsert<T extends commenterUpsertArgs>(args: SelectSubset<T, commenterUpsertArgs<ExtArgs>>): Prisma__commenterClient<$Result.GetResult<Prisma.$commenterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Commenters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commenterCountArgs} args - Arguments to filter Commenters to count.
     * @example
     * // Count the number of Commenters
     * const count = await prisma.commenter.count({
     *   where: {
     *     // ... the filter for the Commenters we want to count
     *   }
     * })
    **/
    count<T extends commenterCountArgs>(
      args?: Subset<T, commenterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommenterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommenterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommenterAggregateArgs>(args: Subset<T, CommenterAggregateArgs>): Prisma.PrismaPromise<GetCommenterAggregateType<T>>

    /**
     * Group by Commenter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commenterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commenterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commenterGroupByArgs['orderBy'] }
        : { orderBy?: commenterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commenterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommenterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the commenter model
   */
  readonly fields: commenterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for commenter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commenterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    utilisateur<T extends UtilisateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UtilisateurDefaultArgs<ExtArgs>>): Prisma__UtilisateurClient<$Result.GetResult<Prisma.$UtilisateurPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    snippet<T extends SnippetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SnippetDefaultArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the commenter model
   */
  interface commenterFieldRefs {
    readonly identifiant_utilisateur: FieldRef<"commenter", 'Int'>
    readonly identifiant_snippet: FieldRef<"commenter", 'Int'>
    readonly date_: FieldRef<"commenter", 'DateTime'>
    readonly texte: FieldRef<"commenter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * commenter findUnique
   */
  export type commenterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    /**
     * Filter, which commenter to fetch.
     */
    where: commenterWhereUniqueInput
  }

  /**
   * commenter findUniqueOrThrow
   */
  export type commenterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    /**
     * Filter, which commenter to fetch.
     */
    where: commenterWhereUniqueInput
  }

  /**
   * commenter findFirst
   */
  export type commenterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    /**
     * Filter, which commenter to fetch.
     */
    where?: commenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commenters to fetch.
     */
    orderBy?: commenterOrderByWithRelationInput | commenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commenters.
     */
    cursor?: commenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commenters.
     */
    distinct?: CommenterScalarFieldEnum | CommenterScalarFieldEnum[]
  }

  /**
   * commenter findFirstOrThrow
   */
  export type commenterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    /**
     * Filter, which commenter to fetch.
     */
    where?: commenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commenters to fetch.
     */
    orderBy?: commenterOrderByWithRelationInput | commenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for commenters.
     */
    cursor?: commenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commenters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of commenters.
     */
    distinct?: CommenterScalarFieldEnum | CommenterScalarFieldEnum[]
  }

  /**
   * commenter findMany
   */
  export type commenterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    /**
     * Filter, which commenters to fetch.
     */
    where?: commenterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of commenters to fetch.
     */
    orderBy?: commenterOrderByWithRelationInput | commenterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing commenters.
     */
    cursor?: commenterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` commenters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` commenters.
     */
    skip?: number
    distinct?: CommenterScalarFieldEnum | CommenterScalarFieldEnum[]
  }

  /**
   * commenter create
   */
  export type commenterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    /**
     * The data needed to create a commenter.
     */
    data: XOR<commenterCreateInput, commenterUncheckedCreateInput>
  }

  /**
   * commenter createMany
   */
  export type commenterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many commenters.
     */
    data: commenterCreateManyInput | commenterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * commenter createManyAndReturn
   */
  export type commenterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * The data used to create many commenters.
     */
    data: commenterCreateManyInput | commenterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * commenter update
   */
  export type commenterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    /**
     * The data needed to update a commenter.
     */
    data: XOR<commenterUpdateInput, commenterUncheckedUpdateInput>
    /**
     * Choose, which commenter to update.
     */
    where: commenterWhereUniqueInput
  }

  /**
   * commenter updateMany
   */
  export type commenterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update commenters.
     */
    data: XOR<commenterUpdateManyMutationInput, commenterUncheckedUpdateManyInput>
    /**
     * Filter which commenters to update
     */
    where?: commenterWhereInput
    /**
     * Limit how many commenters to update.
     */
    limit?: number
  }

  /**
   * commenter updateManyAndReturn
   */
  export type commenterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * The data used to update commenters.
     */
    data: XOR<commenterUpdateManyMutationInput, commenterUncheckedUpdateManyInput>
    /**
     * Filter which commenters to update
     */
    where?: commenterWhereInput
    /**
     * Limit how many commenters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * commenter upsert
   */
  export type commenterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    /**
     * The filter to search for the commenter to update in case it exists.
     */
    where: commenterWhereUniqueInput
    /**
     * In case the commenter found by the `where` argument doesn't exist, create a new commenter with this data.
     */
    create: XOR<commenterCreateInput, commenterUncheckedCreateInput>
    /**
     * In case the commenter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commenterUpdateInput, commenterUncheckedUpdateInput>
  }

  /**
   * commenter delete
   */
  export type commenterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
    /**
     * Filter which commenter to delete.
     */
    where: commenterWhereUniqueInput
  }

  /**
   * commenter deleteMany
   */
  export type commenterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which commenters to delete
     */
    where?: commenterWhereInput
    /**
     * Limit how many commenters to delete.
     */
    limit?: number
  }

  /**
   * commenter without action
   */
  export type commenterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the commenter
     */
    select?: commenterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the commenter
     */
    omit?: commenterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commenterInclude<ExtArgs> | null
  }


  /**
   * Model snippetTag
   */

  export type AggregateSnippetTag = {
    _count: SnippetTagCountAggregateOutputType | null
    _avg: SnippetTagAvgAggregateOutputType | null
    _sum: SnippetTagSumAggregateOutputType | null
    _min: SnippetTagMinAggregateOutputType | null
    _max: SnippetTagMaxAggregateOutputType | null
  }

  export type SnippetTagAvgAggregateOutputType = {
    snippetId: number | null
    tagId: number | null
  }

  export type SnippetTagSumAggregateOutputType = {
    snippetId: number | null
    tagId: number | null
  }

  export type SnippetTagMinAggregateOutputType = {
    snippetId: number | null
    tagId: number | null
  }

  export type SnippetTagMaxAggregateOutputType = {
    snippetId: number | null
    tagId: number | null
  }

  export type SnippetTagCountAggregateOutputType = {
    snippetId: number
    tagId: number
    _all: number
  }


  export type SnippetTagAvgAggregateInputType = {
    snippetId?: true
    tagId?: true
  }

  export type SnippetTagSumAggregateInputType = {
    snippetId?: true
    tagId?: true
  }

  export type SnippetTagMinAggregateInputType = {
    snippetId?: true
    tagId?: true
  }

  export type SnippetTagMaxAggregateInputType = {
    snippetId?: true
    tagId?: true
  }

  export type SnippetTagCountAggregateInputType = {
    snippetId?: true
    tagId?: true
    _all?: true
  }

  export type SnippetTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which snippetTag to aggregate.
     */
    where?: snippetTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of snippetTags to fetch.
     */
    orderBy?: snippetTagOrderByWithRelationInput | snippetTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: snippetTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` snippetTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` snippetTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned snippetTags
    **/
    _count?: true | SnippetTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SnippetTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SnippetTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SnippetTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SnippetTagMaxAggregateInputType
  }

  export type GetSnippetTagAggregateType<T extends SnippetTagAggregateArgs> = {
        [P in keyof T & keyof AggregateSnippetTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSnippetTag[P]>
      : GetScalarType<T[P], AggregateSnippetTag[P]>
  }




  export type snippetTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: snippetTagWhereInput
    orderBy?: snippetTagOrderByWithAggregationInput | snippetTagOrderByWithAggregationInput[]
    by: SnippetTagScalarFieldEnum[] | SnippetTagScalarFieldEnum
    having?: snippetTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SnippetTagCountAggregateInputType | true
    _avg?: SnippetTagAvgAggregateInputType
    _sum?: SnippetTagSumAggregateInputType
    _min?: SnippetTagMinAggregateInputType
    _max?: SnippetTagMaxAggregateInputType
  }

  export type SnippetTagGroupByOutputType = {
    snippetId: number
    tagId: number
    _count: SnippetTagCountAggregateOutputType | null
    _avg: SnippetTagAvgAggregateOutputType | null
    _sum: SnippetTagSumAggregateOutputType | null
    _min: SnippetTagMinAggregateOutputType | null
    _max: SnippetTagMaxAggregateOutputType | null
  }

  type GetSnippetTagGroupByPayload<T extends snippetTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SnippetTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SnippetTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SnippetTagGroupByOutputType[P]>
            : GetScalarType<T[P], SnippetTagGroupByOutputType[P]>
        }
      >
    >


  export type snippetTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    snippetId?: boolean
    tagId?: boolean
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["snippetTag"]>

  export type snippetTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    snippetId?: boolean
    tagId?: boolean
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["snippetTag"]>

  export type snippetTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    snippetId?: boolean
    tagId?: boolean
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["snippetTag"]>

  export type snippetTagSelectScalar = {
    snippetId?: boolean
    tagId?: boolean
  }

  export type snippetTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"snippetId" | "tagId", ExtArgs["result"]["snippetTag"]>
  export type snippetTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type snippetTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type snippetTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snippet?: boolean | SnippetDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $snippetTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "snippetTag"
    objects: {
      snippet: Prisma.$SnippetPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      snippetId: number
      tagId: number
    }, ExtArgs["result"]["snippetTag"]>
    composites: {}
  }

  type snippetTagGetPayload<S extends boolean | null | undefined | snippetTagDefaultArgs> = $Result.GetResult<Prisma.$snippetTagPayload, S>

  type snippetTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<snippetTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SnippetTagCountAggregateInputType | true
    }

  export interface snippetTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['snippetTag'], meta: { name: 'snippetTag' } }
    /**
     * Find zero or one SnippetTag that matches the filter.
     * @param {snippetTagFindUniqueArgs} args - Arguments to find a SnippetTag
     * @example
     * // Get one SnippetTag
     * const snippetTag = await prisma.snippetTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends snippetTagFindUniqueArgs>(args: SelectSubset<T, snippetTagFindUniqueArgs<ExtArgs>>): Prisma__snippetTagClient<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SnippetTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {snippetTagFindUniqueOrThrowArgs} args - Arguments to find a SnippetTag
     * @example
     * // Get one SnippetTag
     * const snippetTag = await prisma.snippetTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends snippetTagFindUniqueOrThrowArgs>(args: SelectSubset<T, snippetTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__snippetTagClient<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SnippetTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snippetTagFindFirstArgs} args - Arguments to find a SnippetTag
     * @example
     * // Get one SnippetTag
     * const snippetTag = await prisma.snippetTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends snippetTagFindFirstArgs>(args?: SelectSubset<T, snippetTagFindFirstArgs<ExtArgs>>): Prisma__snippetTagClient<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SnippetTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snippetTagFindFirstOrThrowArgs} args - Arguments to find a SnippetTag
     * @example
     * // Get one SnippetTag
     * const snippetTag = await prisma.snippetTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends snippetTagFindFirstOrThrowArgs>(args?: SelectSubset<T, snippetTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__snippetTagClient<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SnippetTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snippetTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SnippetTags
     * const snippetTags = await prisma.snippetTag.findMany()
     * 
     * // Get first 10 SnippetTags
     * const snippetTags = await prisma.snippetTag.findMany({ take: 10 })
     * 
     * // Only select the `snippetId`
     * const snippetTagWithSnippetIdOnly = await prisma.snippetTag.findMany({ select: { snippetId: true } })
     * 
     */
    findMany<T extends snippetTagFindManyArgs>(args?: SelectSubset<T, snippetTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SnippetTag.
     * @param {snippetTagCreateArgs} args - Arguments to create a SnippetTag.
     * @example
     * // Create one SnippetTag
     * const SnippetTag = await prisma.snippetTag.create({
     *   data: {
     *     // ... data to create a SnippetTag
     *   }
     * })
     * 
     */
    create<T extends snippetTagCreateArgs>(args: SelectSubset<T, snippetTagCreateArgs<ExtArgs>>): Prisma__snippetTagClient<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SnippetTags.
     * @param {snippetTagCreateManyArgs} args - Arguments to create many SnippetTags.
     * @example
     * // Create many SnippetTags
     * const snippetTag = await prisma.snippetTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends snippetTagCreateManyArgs>(args?: SelectSubset<T, snippetTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SnippetTags and returns the data saved in the database.
     * @param {snippetTagCreateManyAndReturnArgs} args - Arguments to create many SnippetTags.
     * @example
     * // Create many SnippetTags
     * const snippetTag = await prisma.snippetTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SnippetTags and only return the `snippetId`
     * const snippetTagWithSnippetIdOnly = await prisma.snippetTag.createManyAndReturn({
     *   select: { snippetId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends snippetTagCreateManyAndReturnArgs>(args?: SelectSubset<T, snippetTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SnippetTag.
     * @param {snippetTagDeleteArgs} args - Arguments to delete one SnippetTag.
     * @example
     * // Delete one SnippetTag
     * const SnippetTag = await prisma.snippetTag.delete({
     *   where: {
     *     // ... filter to delete one SnippetTag
     *   }
     * })
     * 
     */
    delete<T extends snippetTagDeleteArgs>(args: SelectSubset<T, snippetTagDeleteArgs<ExtArgs>>): Prisma__snippetTagClient<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SnippetTag.
     * @param {snippetTagUpdateArgs} args - Arguments to update one SnippetTag.
     * @example
     * // Update one SnippetTag
     * const snippetTag = await prisma.snippetTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends snippetTagUpdateArgs>(args: SelectSubset<T, snippetTagUpdateArgs<ExtArgs>>): Prisma__snippetTagClient<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SnippetTags.
     * @param {snippetTagDeleteManyArgs} args - Arguments to filter SnippetTags to delete.
     * @example
     * // Delete a few SnippetTags
     * const { count } = await prisma.snippetTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends snippetTagDeleteManyArgs>(args?: SelectSubset<T, snippetTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SnippetTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snippetTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SnippetTags
     * const snippetTag = await prisma.snippetTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends snippetTagUpdateManyArgs>(args: SelectSubset<T, snippetTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SnippetTags and returns the data updated in the database.
     * @param {snippetTagUpdateManyAndReturnArgs} args - Arguments to update many SnippetTags.
     * @example
     * // Update many SnippetTags
     * const snippetTag = await prisma.snippetTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SnippetTags and only return the `snippetId`
     * const snippetTagWithSnippetIdOnly = await prisma.snippetTag.updateManyAndReturn({
     *   select: { snippetId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends snippetTagUpdateManyAndReturnArgs>(args: SelectSubset<T, snippetTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SnippetTag.
     * @param {snippetTagUpsertArgs} args - Arguments to update or create a SnippetTag.
     * @example
     * // Update or create a SnippetTag
     * const snippetTag = await prisma.snippetTag.upsert({
     *   create: {
     *     // ... data to create a SnippetTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SnippetTag we want to update
     *   }
     * })
     */
    upsert<T extends snippetTagUpsertArgs>(args: SelectSubset<T, snippetTagUpsertArgs<ExtArgs>>): Prisma__snippetTagClient<$Result.GetResult<Prisma.$snippetTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SnippetTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snippetTagCountArgs} args - Arguments to filter SnippetTags to count.
     * @example
     * // Count the number of SnippetTags
     * const count = await prisma.snippetTag.count({
     *   where: {
     *     // ... the filter for the SnippetTags we want to count
     *   }
     * })
    **/
    count<T extends snippetTagCountArgs>(
      args?: Subset<T, snippetTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SnippetTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SnippetTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SnippetTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SnippetTagAggregateArgs>(args: Subset<T, SnippetTagAggregateArgs>): Prisma.PrismaPromise<GetSnippetTagAggregateType<T>>

    /**
     * Group by SnippetTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {snippetTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends snippetTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: snippetTagGroupByArgs['orderBy'] }
        : { orderBy?: snippetTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, snippetTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSnippetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the snippetTag model
   */
  readonly fields: snippetTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for snippetTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__snippetTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    snippet<T extends SnippetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SnippetDefaultArgs<ExtArgs>>): Prisma__SnippetClient<$Result.GetResult<Prisma.$SnippetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the snippetTag model
   */
  interface snippetTagFieldRefs {
    readonly snippetId: FieldRef<"snippetTag", 'Int'>
    readonly tagId: FieldRef<"snippetTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * snippetTag findUnique
   */
  export type snippetTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    /**
     * Filter, which snippetTag to fetch.
     */
    where: snippetTagWhereUniqueInput
  }

  /**
   * snippetTag findUniqueOrThrow
   */
  export type snippetTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    /**
     * Filter, which snippetTag to fetch.
     */
    where: snippetTagWhereUniqueInput
  }

  /**
   * snippetTag findFirst
   */
  export type snippetTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    /**
     * Filter, which snippetTag to fetch.
     */
    where?: snippetTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of snippetTags to fetch.
     */
    orderBy?: snippetTagOrderByWithRelationInput | snippetTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for snippetTags.
     */
    cursor?: snippetTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` snippetTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` snippetTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of snippetTags.
     */
    distinct?: SnippetTagScalarFieldEnum | SnippetTagScalarFieldEnum[]
  }

  /**
   * snippetTag findFirstOrThrow
   */
  export type snippetTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    /**
     * Filter, which snippetTag to fetch.
     */
    where?: snippetTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of snippetTags to fetch.
     */
    orderBy?: snippetTagOrderByWithRelationInput | snippetTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for snippetTags.
     */
    cursor?: snippetTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` snippetTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` snippetTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of snippetTags.
     */
    distinct?: SnippetTagScalarFieldEnum | SnippetTagScalarFieldEnum[]
  }

  /**
   * snippetTag findMany
   */
  export type snippetTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    /**
     * Filter, which snippetTags to fetch.
     */
    where?: snippetTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of snippetTags to fetch.
     */
    orderBy?: snippetTagOrderByWithRelationInput | snippetTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing snippetTags.
     */
    cursor?: snippetTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` snippetTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` snippetTags.
     */
    skip?: number
    distinct?: SnippetTagScalarFieldEnum | SnippetTagScalarFieldEnum[]
  }

  /**
   * snippetTag create
   */
  export type snippetTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    /**
     * The data needed to create a snippetTag.
     */
    data: XOR<snippetTagCreateInput, snippetTagUncheckedCreateInput>
  }

  /**
   * snippetTag createMany
   */
  export type snippetTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many snippetTags.
     */
    data: snippetTagCreateManyInput | snippetTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * snippetTag createManyAndReturn
   */
  export type snippetTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * The data used to create many snippetTags.
     */
    data: snippetTagCreateManyInput | snippetTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * snippetTag update
   */
  export type snippetTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    /**
     * The data needed to update a snippetTag.
     */
    data: XOR<snippetTagUpdateInput, snippetTagUncheckedUpdateInput>
    /**
     * Choose, which snippetTag to update.
     */
    where: snippetTagWhereUniqueInput
  }

  /**
   * snippetTag updateMany
   */
  export type snippetTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update snippetTags.
     */
    data: XOR<snippetTagUpdateManyMutationInput, snippetTagUncheckedUpdateManyInput>
    /**
     * Filter which snippetTags to update
     */
    where?: snippetTagWhereInput
    /**
     * Limit how many snippetTags to update.
     */
    limit?: number
  }

  /**
   * snippetTag updateManyAndReturn
   */
  export type snippetTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * The data used to update snippetTags.
     */
    data: XOR<snippetTagUpdateManyMutationInput, snippetTagUncheckedUpdateManyInput>
    /**
     * Filter which snippetTags to update
     */
    where?: snippetTagWhereInput
    /**
     * Limit how many snippetTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * snippetTag upsert
   */
  export type snippetTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    /**
     * The filter to search for the snippetTag to update in case it exists.
     */
    where: snippetTagWhereUniqueInput
    /**
     * In case the snippetTag found by the `where` argument doesn't exist, create a new snippetTag with this data.
     */
    create: XOR<snippetTagCreateInput, snippetTagUncheckedCreateInput>
    /**
     * In case the snippetTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<snippetTagUpdateInput, snippetTagUncheckedUpdateInput>
  }

  /**
   * snippetTag delete
   */
  export type snippetTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
    /**
     * Filter which snippetTag to delete.
     */
    where: snippetTagWhereUniqueInput
  }

  /**
   * snippetTag deleteMany
   */
  export type snippetTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which snippetTags to delete
     */
    where?: snippetTagWhereInput
    /**
     * Limit how many snippetTags to delete.
     */
    limit?: number
  }

  /**
   * snippetTag without action
   */
  export type snippetTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the snippetTag
     */
    select?: snippetTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the snippetTag
     */
    omit?: snippetTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: snippetTagInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UtilisateurScalarFieldEnum: {
    identifiant_utilisateur: 'identifiant_utilisateur',
    email: 'email',
    motdepasse_hash: 'motdepasse_hash',
    creer_le: 'creer_le'
  };

  export type UtilisateurScalarFieldEnum = (typeof UtilisateurScalarFieldEnum)[keyof typeof UtilisateurScalarFieldEnum]


  export const SnippetScalarFieldEnum: {
    identifiant_snippet: 'identifiant_snippet',
    titre: 'titre',
    code: 'code',
    langage: 'langage',
    visibilite: 'visibilite',
    creer_le: 'creer_le',
    identifiant_utilisateur: 'identifiant_utilisateur'
  };

  export type SnippetScalarFieldEnum = (typeof SnippetScalarFieldEnum)[keyof typeof SnippetScalarFieldEnum]


  export const TagScalarFieldEnum: {
    identifiant_tag: 'identifiant_tag',
    name: 'name'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const AimerScalarFieldEnum: {
    identifiant_utilisateur: 'identifiant_utilisateur',
    identifiant_snippet: 'identifiant_snippet'
  };

  export type AimerScalarFieldEnum = (typeof AimerScalarFieldEnum)[keyof typeof AimerScalarFieldEnum]


  export const CommenterScalarFieldEnum: {
    identifiant_utilisateur: 'identifiant_utilisateur',
    identifiant_snippet: 'identifiant_snippet',
    date_: 'date_',
    texte: 'texte'
  };

  export type CommenterScalarFieldEnum = (typeof CommenterScalarFieldEnum)[keyof typeof CommenterScalarFieldEnum]


  export const SnippetTagScalarFieldEnum: {
    snippetId: 'snippetId',
    tagId: 'tagId'
  };

  export type SnippetTagScalarFieldEnum = (typeof SnippetTagScalarFieldEnum)[keyof typeof SnippetTagScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UtilisateurWhereInput = {
    AND?: UtilisateurWhereInput | UtilisateurWhereInput[]
    OR?: UtilisateurWhereInput[]
    NOT?: UtilisateurWhereInput | UtilisateurWhereInput[]
    identifiant_utilisateur?: IntFilter<"Utilisateur"> | number
    email?: StringFilter<"Utilisateur"> | string
    motdepasse_hash?: StringFilter<"Utilisateur"> | string
    creer_le?: DateTimeFilter<"Utilisateur"> | Date | string
    snippets?: SnippetListRelationFilter
    aimer?: AimerListRelationFilter
    commenter?: CommenterListRelationFilter
  }

  export type UtilisateurOrderByWithRelationInput = {
    identifiant_utilisateur?: SortOrder
    email?: SortOrder
    motdepasse_hash?: SortOrder
    creer_le?: SortOrder
    snippets?: SnippetOrderByRelationAggregateInput
    aimer?: aimerOrderByRelationAggregateInput
    commenter?: commenterOrderByRelationAggregateInput
  }

  export type UtilisateurWhereUniqueInput = Prisma.AtLeast<{
    identifiant_utilisateur?: number
    email?: string
    AND?: UtilisateurWhereInput | UtilisateurWhereInput[]
    OR?: UtilisateurWhereInput[]
    NOT?: UtilisateurWhereInput | UtilisateurWhereInput[]
    motdepasse_hash?: StringFilter<"Utilisateur"> | string
    creer_le?: DateTimeFilter<"Utilisateur"> | Date | string
    snippets?: SnippetListRelationFilter
    aimer?: AimerListRelationFilter
    commenter?: CommenterListRelationFilter
  }, "identifiant_utilisateur" | "email">

  export type UtilisateurOrderByWithAggregationInput = {
    identifiant_utilisateur?: SortOrder
    email?: SortOrder
    motdepasse_hash?: SortOrder
    creer_le?: SortOrder
    _count?: UtilisateurCountOrderByAggregateInput
    _avg?: UtilisateurAvgOrderByAggregateInput
    _max?: UtilisateurMaxOrderByAggregateInput
    _min?: UtilisateurMinOrderByAggregateInput
    _sum?: UtilisateurSumOrderByAggregateInput
  }

  export type UtilisateurScalarWhereWithAggregatesInput = {
    AND?: UtilisateurScalarWhereWithAggregatesInput | UtilisateurScalarWhereWithAggregatesInput[]
    OR?: UtilisateurScalarWhereWithAggregatesInput[]
    NOT?: UtilisateurScalarWhereWithAggregatesInput | UtilisateurScalarWhereWithAggregatesInput[]
    identifiant_utilisateur?: IntWithAggregatesFilter<"Utilisateur"> | number
    email?: StringWithAggregatesFilter<"Utilisateur"> | string
    motdepasse_hash?: StringWithAggregatesFilter<"Utilisateur"> | string
    creer_le?: DateTimeWithAggregatesFilter<"Utilisateur"> | Date | string
  }

  export type SnippetWhereInput = {
    AND?: SnippetWhereInput | SnippetWhereInput[]
    OR?: SnippetWhereInput[]
    NOT?: SnippetWhereInput | SnippetWhereInput[]
    identifiant_snippet?: IntFilter<"Snippet"> | number
    titre?: StringNullableFilter<"Snippet"> | string | null
    code?: StringNullableFilter<"Snippet"> | string | null
    langage?: StringNullableFilter<"Snippet"> | string | null
    visibilite?: StringNullableFilter<"Snippet"> | string | null
    creer_le?: DateTimeFilter<"Snippet"> | Date | string
    identifiant_utilisateur?: IntFilter<"Snippet"> | number
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    aimer?: AimerListRelationFilter
    commenter?: CommenterListRelationFilter
    snippetTag?: SnippetTagListRelationFilter
  }

  export type SnippetOrderByWithRelationInput = {
    identifiant_snippet?: SortOrder
    titre?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    langage?: SortOrderInput | SortOrder
    visibilite?: SortOrderInput | SortOrder
    creer_le?: SortOrder
    identifiant_utilisateur?: SortOrder
    utilisateur?: UtilisateurOrderByWithRelationInput
    aimer?: aimerOrderByRelationAggregateInput
    commenter?: commenterOrderByRelationAggregateInput
    snippetTag?: snippetTagOrderByRelationAggregateInput
  }

  export type SnippetWhereUniqueInput = Prisma.AtLeast<{
    identifiant_snippet?: number
    AND?: SnippetWhereInput | SnippetWhereInput[]
    OR?: SnippetWhereInput[]
    NOT?: SnippetWhereInput | SnippetWhereInput[]
    titre?: StringNullableFilter<"Snippet"> | string | null
    code?: StringNullableFilter<"Snippet"> | string | null
    langage?: StringNullableFilter<"Snippet"> | string | null
    visibilite?: StringNullableFilter<"Snippet"> | string | null
    creer_le?: DateTimeFilter<"Snippet"> | Date | string
    identifiant_utilisateur?: IntFilter<"Snippet"> | number
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    aimer?: AimerListRelationFilter
    commenter?: CommenterListRelationFilter
    snippetTag?: SnippetTagListRelationFilter
  }, "identifiant_snippet">

  export type SnippetOrderByWithAggregationInput = {
    identifiant_snippet?: SortOrder
    titre?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    langage?: SortOrderInput | SortOrder
    visibilite?: SortOrderInput | SortOrder
    creer_le?: SortOrder
    identifiant_utilisateur?: SortOrder
    _count?: SnippetCountOrderByAggregateInput
    _avg?: SnippetAvgOrderByAggregateInput
    _max?: SnippetMaxOrderByAggregateInput
    _min?: SnippetMinOrderByAggregateInput
    _sum?: SnippetSumOrderByAggregateInput
  }

  export type SnippetScalarWhereWithAggregatesInput = {
    AND?: SnippetScalarWhereWithAggregatesInput | SnippetScalarWhereWithAggregatesInput[]
    OR?: SnippetScalarWhereWithAggregatesInput[]
    NOT?: SnippetScalarWhereWithAggregatesInput | SnippetScalarWhereWithAggregatesInput[]
    identifiant_snippet?: IntWithAggregatesFilter<"Snippet"> | number
    titre?: StringNullableWithAggregatesFilter<"Snippet"> | string | null
    code?: StringNullableWithAggregatesFilter<"Snippet"> | string | null
    langage?: StringNullableWithAggregatesFilter<"Snippet"> | string | null
    visibilite?: StringNullableWithAggregatesFilter<"Snippet"> | string | null
    creer_le?: DateTimeWithAggregatesFilter<"Snippet"> | Date | string
    identifiant_utilisateur?: IntWithAggregatesFilter<"Snippet"> | number
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    identifiant_tag?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    snippetTag?: SnippetTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    identifiant_tag?: SortOrder
    name?: SortOrder
    snippetTag?: snippetTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    identifiant_tag?: number
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    snippetTag?: SnippetTagListRelationFilter
  }, "identifiant_tag" | "name">

  export type TagOrderByWithAggregationInput = {
    identifiant_tag?: SortOrder
    name?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    identifiant_tag?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type aimerWhereInput = {
    AND?: aimerWhereInput | aimerWhereInput[]
    OR?: aimerWhereInput[]
    NOT?: aimerWhereInput | aimerWhereInput[]
    identifiant_utilisateur?: IntFilter<"aimer"> | number
    identifiant_snippet?: IntFilter<"aimer"> | number
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    snippet?: XOR<SnippetScalarRelationFilter, SnippetWhereInput>
  }

  export type aimerOrderByWithRelationInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
    utilisateur?: UtilisateurOrderByWithRelationInput
    snippet?: SnippetOrderByWithRelationInput
  }

  export type aimerWhereUniqueInput = Prisma.AtLeast<{
    identifiant_utilisateur_identifiant_snippet?: aimerIdentifiant_utilisateurIdentifiant_snippetCompoundUniqueInput
    AND?: aimerWhereInput | aimerWhereInput[]
    OR?: aimerWhereInput[]
    NOT?: aimerWhereInput | aimerWhereInput[]
    identifiant_utilisateur?: IntFilter<"aimer"> | number
    identifiant_snippet?: IntFilter<"aimer"> | number
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    snippet?: XOR<SnippetScalarRelationFilter, SnippetWhereInput>
  }, "identifiant_utilisateur_identifiant_snippet">

  export type aimerOrderByWithAggregationInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
    _count?: aimerCountOrderByAggregateInput
    _avg?: aimerAvgOrderByAggregateInput
    _max?: aimerMaxOrderByAggregateInput
    _min?: aimerMinOrderByAggregateInput
    _sum?: aimerSumOrderByAggregateInput
  }

  export type aimerScalarWhereWithAggregatesInput = {
    AND?: aimerScalarWhereWithAggregatesInput | aimerScalarWhereWithAggregatesInput[]
    OR?: aimerScalarWhereWithAggregatesInput[]
    NOT?: aimerScalarWhereWithAggregatesInput | aimerScalarWhereWithAggregatesInput[]
    identifiant_utilisateur?: IntWithAggregatesFilter<"aimer"> | number
    identifiant_snippet?: IntWithAggregatesFilter<"aimer"> | number
  }

  export type commenterWhereInput = {
    AND?: commenterWhereInput | commenterWhereInput[]
    OR?: commenterWhereInput[]
    NOT?: commenterWhereInput | commenterWhereInput[]
    identifiant_utilisateur?: IntFilter<"commenter"> | number
    identifiant_snippet?: IntFilter<"commenter"> | number
    date_?: DateTimeFilter<"commenter"> | Date | string
    texte?: StringNullableFilter<"commenter"> | string | null
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    snippet?: XOR<SnippetScalarRelationFilter, SnippetWhereInput>
  }

  export type commenterOrderByWithRelationInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
    date_?: SortOrder
    texte?: SortOrderInput | SortOrder
    utilisateur?: UtilisateurOrderByWithRelationInput
    snippet?: SnippetOrderByWithRelationInput
  }

  export type commenterWhereUniqueInput = Prisma.AtLeast<{
    identifiant_utilisateur_identifiant_snippet?: commenterIdentifiant_utilisateurIdentifiant_snippetCompoundUniqueInput
    AND?: commenterWhereInput | commenterWhereInput[]
    OR?: commenterWhereInput[]
    NOT?: commenterWhereInput | commenterWhereInput[]
    identifiant_utilisateur?: IntFilter<"commenter"> | number
    identifiant_snippet?: IntFilter<"commenter"> | number
    date_?: DateTimeFilter<"commenter"> | Date | string
    texte?: StringNullableFilter<"commenter"> | string | null
    utilisateur?: XOR<UtilisateurScalarRelationFilter, UtilisateurWhereInput>
    snippet?: XOR<SnippetScalarRelationFilter, SnippetWhereInput>
  }, "identifiant_utilisateur_identifiant_snippet">

  export type commenterOrderByWithAggregationInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
    date_?: SortOrder
    texte?: SortOrderInput | SortOrder
    _count?: commenterCountOrderByAggregateInput
    _avg?: commenterAvgOrderByAggregateInput
    _max?: commenterMaxOrderByAggregateInput
    _min?: commenterMinOrderByAggregateInput
    _sum?: commenterSumOrderByAggregateInput
  }

  export type commenterScalarWhereWithAggregatesInput = {
    AND?: commenterScalarWhereWithAggregatesInput | commenterScalarWhereWithAggregatesInput[]
    OR?: commenterScalarWhereWithAggregatesInput[]
    NOT?: commenterScalarWhereWithAggregatesInput | commenterScalarWhereWithAggregatesInput[]
    identifiant_utilisateur?: IntWithAggregatesFilter<"commenter"> | number
    identifiant_snippet?: IntWithAggregatesFilter<"commenter"> | number
    date_?: DateTimeWithAggregatesFilter<"commenter"> | Date | string
    texte?: StringNullableWithAggregatesFilter<"commenter"> | string | null
  }

  export type snippetTagWhereInput = {
    AND?: snippetTagWhereInput | snippetTagWhereInput[]
    OR?: snippetTagWhereInput[]
    NOT?: snippetTagWhereInput | snippetTagWhereInput[]
    snippetId?: IntFilter<"snippetTag"> | number
    tagId?: IntFilter<"snippetTag"> | number
    snippet?: XOR<SnippetScalarRelationFilter, SnippetWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type snippetTagOrderByWithRelationInput = {
    snippetId?: SortOrder
    tagId?: SortOrder
    snippet?: SnippetOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type snippetTagWhereUniqueInput = Prisma.AtLeast<{
    snippetId_tagId?: snippetTagSnippetIdTagIdCompoundUniqueInput
    AND?: snippetTagWhereInput | snippetTagWhereInput[]
    OR?: snippetTagWhereInput[]
    NOT?: snippetTagWhereInput | snippetTagWhereInput[]
    snippetId?: IntFilter<"snippetTag"> | number
    tagId?: IntFilter<"snippetTag"> | number
    snippet?: XOR<SnippetScalarRelationFilter, SnippetWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "snippetId_tagId">

  export type snippetTagOrderByWithAggregationInput = {
    snippetId?: SortOrder
    tagId?: SortOrder
    _count?: snippetTagCountOrderByAggregateInput
    _avg?: snippetTagAvgOrderByAggregateInput
    _max?: snippetTagMaxOrderByAggregateInput
    _min?: snippetTagMinOrderByAggregateInput
    _sum?: snippetTagSumOrderByAggregateInput
  }

  export type snippetTagScalarWhereWithAggregatesInput = {
    AND?: snippetTagScalarWhereWithAggregatesInput | snippetTagScalarWhereWithAggregatesInput[]
    OR?: snippetTagScalarWhereWithAggregatesInput[]
    NOT?: snippetTagScalarWhereWithAggregatesInput | snippetTagScalarWhereWithAggregatesInput[]
    snippetId?: IntWithAggregatesFilter<"snippetTag"> | number
    tagId?: IntWithAggregatesFilter<"snippetTag"> | number
  }

  export type UtilisateurCreateInput = {
    email: string
    motdepasse_hash: string
    creer_le?: Date | string
    snippets?: SnippetCreateNestedManyWithoutUtilisateurInput
    aimer?: aimerCreateNestedManyWithoutUtilisateurInput
    commenter?: commenterCreateNestedManyWithoutUtilisateurInput
  }

  export type UtilisateurUncheckedCreateInput = {
    identifiant_utilisateur?: number
    email: string
    motdepasse_hash: string
    creer_le?: Date | string
    snippets?: SnippetUncheckedCreateNestedManyWithoutUtilisateurInput
    aimer?: aimerUncheckedCreateNestedManyWithoutUtilisateurInput
    commenter?: commenterUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type UtilisateurUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    motdepasse_hash?: StringFieldUpdateOperationsInput | string
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    snippets?: SnippetUpdateManyWithoutUtilisateurNestedInput
    aimer?: aimerUpdateManyWithoutUtilisateurNestedInput
    commenter?: commenterUpdateManyWithoutUtilisateurNestedInput
  }

  export type UtilisateurUncheckedUpdateInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    motdepasse_hash?: StringFieldUpdateOperationsInput | string
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    snippets?: SnippetUncheckedUpdateManyWithoutUtilisateurNestedInput
    aimer?: aimerUncheckedUpdateManyWithoutUtilisateurNestedInput
    commenter?: commenterUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type UtilisateurCreateManyInput = {
    identifiant_utilisateur?: number
    email: string
    motdepasse_hash: string
    creer_le?: Date | string
  }

  export type UtilisateurUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    motdepasse_hash?: StringFieldUpdateOperationsInput | string
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UtilisateurUncheckedUpdateManyInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    motdepasse_hash?: StringFieldUpdateOperationsInput | string
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnippetCreateInput = {
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutSnippetsInput
    aimer?: aimerCreateNestedManyWithoutSnippetInput
    commenter?: commenterCreateNestedManyWithoutSnippetInput
    snippetTag?: snippetTagCreateNestedManyWithoutSnippetInput
  }

  export type SnippetUncheckedCreateInput = {
    identifiant_snippet?: number
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    identifiant_utilisateur: number
    aimer?: aimerUncheckedCreateNestedManyWithoutSnippetInput
    commenter?: commenterUncheckedCreateNestedManyWithoutSnippetInput
    snippetTag?: snippetTagUncheckedCreateNestedManyWithoutSnippetInput
  }

  export type SnippetUpdateInput = {
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutSnippetsNestedInput
    aimer?: aimerUpdateManyWithoutSnippetNestedInput
    commenter?: commenterUpdateManyWithoutSnippetNestedInput
    snippetTag?: snippetTagUpdateManyWithoutSnippetNestedInput
  }

  export type SnippetUncheckedUpdateInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    aimer?: aimerUncheckedUpdateManyWithoutSnippetNestedInput
    commenter?: commenterUncheckedUpdateManyWithoutSnippetNestedInput
    snippetTag?: snippetTagUncheckedUpdateManyWithoutSnippetNestedInput
  }

  export type SnippetCreateManyInput = {
    identifiant_snippet?: number
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    identifiant_utilisateur: number
  }

  export type SnippetUpdateManyMutationInput = {
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SnippetUncheckedUpdateManyInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
  }

  export type TagCreateInput = {
    name: string
    snippetTag?: snippetTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    identifiant_tag?: number
    name: string
    snippetTag?: snippetTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    snippetTag?: snippetTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    identifiant_tag?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    snippetTag?: snippetTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    identifiant_tag?: number
    name: string
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    identifiant_tag?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type aimerCreateInput = {
    utilisateur: UtilisateurCreateNestedOneWithoutAimerInput
    snippet: SnippetCreateNestedOneWithoutAimerInput
  }

  export type aimerUncheckedCreateInput = {
    identifiant_utilisateur: number
    identifiant_snippet: number
  }

  export type aimerUpdateInput = {
    utilisateur?: UtilisateurUpdateOneRequiredWithoutAimerNestedInput
    snippet?: SnippetUpdateOneRequiredWithoutAimerNestedInput
  }

  export type aimerUncheckedUpdateInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
  }

  export type aimerCreateManyInput = {
    identifiant_utilisateur: number
    identifiant_snippet: number
  }

  export type aimerUpdateManyMutationInput = {

  }

  export type aimerUncheckedUpdateManyInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
  }

  export type commenterCreateInput = {
    date_?: Date | string
    texte?: string | null
    utilisateur: UtilisateurCreateNestedOneWithoutCommenterInput
    snippet: SnippetCreateNestedOneWithoutCommenterInput
  }

  export type commenterUncheckedCreateInput = {
    identifiant_utilisateur: number
    identifiant_snippet: number
    date_?: Date | string
    texte?: string | null
  }

  export type commenterUpdateInput = {
    date_?: DateTimeFieldUpdateOperationsInput | Date | string
    texte?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: UtilisateurUpdateOneRequiredWithoutCommenterNestedInput
    snippet?: SnippetUpdateOneRequiredWithoutCommenterNestedInput
  }

  export type commenterUncheckedUpdateInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    date_?: DateTimeFieldUpdateOperationsInput | Date | string
    texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commenterCreateManyInput = {
    identifiant_utilisateur: number
    identifiant_snippet: number
    date_?: Date | string
    texte?: string | null
  }

  export type commenterUpdateManyMutationInput = {
    date_?: DateTimeFieldUpdateOperationsInput | Date | string
    texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commenterUncheckedUpdateManyInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    date_?: DateTimeFieldUpdateOperationsInput | Date | string
    texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type snippetTagCreateInput = {
    snippet: SnippetCreateNestedOneWithoutSnippetTagInput
    tag: TagCreateNestedOneWithoutSnippetTagInput
  }

  export type snippetTagUncheckedCreateInput = {
    snippetId: number
    tagId: number
  }

  export type snippetTagUpdateInput = {
    snippet?: SnippetUpdateOneRequiredWithoutSnippetTagNestedInput
    tag?: TagUpdateOneRequiredWithoutSnippetTagNestedInput
  }

  export type snippetTagUncheckedUpdateInput = {
    snippetId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type snippetTagCreateManyInput = {
    snippetId: number
    tagId: number
  }

  export type snippetTagUpdateManyMutationInput = {

  }

  export type snippetTagUncheckedUpdateManyInput = {
    snippetId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SnippetListRelationFilter = {
    every?: SnippetWhereInput
    some?: SnippetWhereInput
    none?: SnippetWhereInput
  }

  export type AimerListRelationFilter = {
    every?: aimerWhereInput
    some?: aimerWhereInput
    none?: aimerWhereInput
  }

  export type CommenterListRelationFilter = {
    every?: commenterWhereInput
    some?: commenterWhereInput
    none?: commenterWhereInput
  }

  export type SnippetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type aimerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type commenterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UtilisateurCountOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    email?: SortOrder
    motdepasse_hash?: SortOrder
    creer_le?: SortOrder
  }

  export type UtilisateurAvgOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
  }

  export type UtilisateurMaxOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    email?: SortOrder
    motdepasse_hash?: SortOrder
    creer_le?: SortOrder
  }

  export type UtilisateurMinOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    email?: SortOrder
    motdepasse_hash?: SortOrder
    creer_le?: SortOrder
  }

  export type UtilisateurSumOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UtilisateurScalarRelationFilter = {
    is?: UtilisateurWhereInput
    isNot?: UtilisateurWhereInput
  }

  export type SnippetTagListRelationFilter = {
    every?: snippetTagWhereInput
    some?: snippetTagWhereInput
    none?: snippetTagWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type snippetTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SnippetCountOrderByAggregateInput = {
    identifiant_snippet?: SortOrder
    titre?: SortOrder
    code?: SortOrder
    langage?: SortOrder
    visibilite?: SortOrder
    creer_le?: SortOrder
    identifiant_utilisateur?: SortOrder
  }

  export type SnippetAvgOrderByAggregateInput = {
    identifiant_snippet?: SortOrder
    identifiant_utilisateur?: SortOrder
  }

  export type SnippetMaxOrderByAggregateInput = {
    identifiant_snippet?: SortOrder
    titre?: SortOrder
    code?: SortOrder
    langage?: SortOrder
    visibilite?: SortOrder
    creer_le?: SortOrder
    identifiant_utilisateur?: SortOrder
  }

  export type SnippetMinOrderByAggregateInput = {
    identifiant_snippet?: SortOrder
    titre?: SortOrder
    code?: SortOrder
    langage?: SortOrder
    visibilite?: SortOrder
    creer_le?: SortOrder
    identifiant_utilisateur?: SortOrder
  }

  export type SnippetSumOrderByAggregateInput = {
    identifiant_snippet?: SortOrder
    identifiant_utilisateur?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type TagCountOrderByAggregateInput = {
    identifiant_tag?: SortOrder
    name?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    identifiant_tag?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    identifiant_tag?: SortOrder
    name?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    identifiant_tag?: SortOrder
    name?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    identifiant_tag?: SortOrder
  }

  export type SnippetScalarRelationFilter = {
    is?: SnippetWhereInput
    isNot?: SnippetWhereInput
  }

  export type aimerIdentifiant_utilisateurIdentifiant_snippetCompoundUniqueInput = {
    identifiant_utilisateur: number
    identifiant_snippet: number
  }

  export type aimerCountOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
  }

  export type aimerAvgOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
  }

  export type aimerMaxOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
  }

  export type aimerMinOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
  }

  export type aimerSumOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
  }

  export type commenterIdentifiant_utilisateurIdentifiant_snippetCompoundUniqueInput = {
    identifiant_utilisateur: number
    identifiant_snippet: number
  }

  export type commenterCountOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
    date_?: SortOrder
    texte?: SortOrder
  }

  export type commenterAvgOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
  }

  export type commenterMaxOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
    date_?: SortOrder
    texte?: SortOrder
  }

  export type commenterMinOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
    date_?: SortOrder
    texte?: SortOrder
  }

  export type commenterSumOrderByAggregateInput = {
    identifiant_utilisateur?: SortOrder
    identifiant_snippet?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type snippetTagSnippetIdTagIdCompoundUniqueInput = {
    snippetId: number
    tagId: number
  }

  export type snippetTagCountOrderByAggregateInput = {
    snippetId?: SortOrder
    tagId?: SortOrder
  }

  export type snippetTagAvgOrderByAggregateInput = {
    snippetId?: SortOrder
    tagId?: SortOrder
  }

  export type snippetTagMaxOrderByAggregateInput = {
    snippetId?: SortOrder
    tagId?: SortOrder
  }

  export type snippetTagMinOrderByAggregateInput = {
    snippetId?: SortOrder
    tagId?: SortOrder
  }

  export type snippetTagSumOrderByAggregateInput = {
    snippetId?: SortOrder
    tagId?: SortOrder
  }

  export type SnippetCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<SnippetCreateWithoutUtilisateurInput, SnippetUncheckedCreateWithoutUtilisateurInput> | SnippetCreateWithoutUtilisateurInput[] | SnippetUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: SnippetCreateOrConnectWithoutUtilisateurInput | SnippetCreateOrConnectWithoutUtilisateurInput[]
    createMany?: SnippetCreateManyUtilisateurInputEnvelope
    connect?: SnippetWhereUniqueInput | SnippetWhereUniqueInput[]
  }

  export type aimerCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<aimerCreateWithoutUtilisateurInput, aimerUncheckedCreateWithoutUtilisateurInput> | aimerCreateWithoutUtilisateurInput[] | aimerUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: aimerCreateOrConnectWithoutUtilisateurInput | aimerCreateOrConnectWithoutUtilisateurInput[]
    createMany?: aimerCreateManyUtilisateurInputEnvelope
    connect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
  }

  export type commenterCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<commenterCreateWithoutUtilisateurInput, commenterUncheckedCreateWithoutUtilisateurInput> | commenterCreateWithoutUtilisateurInput[] | commenterUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: commenterCreateOrConnectWithoutUtilisateurInput | commenterCreateOrConnectWithoutUtilisateurInput[]
    createMany?: commenterCreateManyUtilisateurInputEnvelope
    connect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
  }

  export type SnippetUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<SnippetCreateWithoutUtilisateurInput, SnippetUncheckedCreateWithoutUtilisateurInput> | SnippetCreateWithoutUtilisateurInput[] | SnippetUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: SnippetCreateOrConnectWithoutUtilisateurInput | SnippetCreateOrConnectWithoutUtilisateurInput[]
    createMany?: SnippetCreateManyUtilisateurInputEnvelope
    connect?: SnippetWhereUniqueInput | SnippetWhereUniqueInput[]
  }

  export type aimerUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<aimerCreateWithoutUtilisateurInput, aimerUncheckedCreateWithoutUtilisateurInput> | aimerCreateWithoutUtilisateurInput[] | aimerUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: aimerCreateOrConnectWithoutUtilisateurInput | aimerCreateOrConnectWithoutUtilisateurInput[]
    createMany?: aimerCreateManyUtilisateurInputEnvelope
    connect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
  }

  export type commenterUncheckedCreateNestedManyWithoutUtilisateurInput = {
    create?: XOR<commenterCreateWithoutUtilisateurInput, commenterUncheckedCreateWithoutUtilisateurInput> | commenterCreateWithoutUtilisateurInput[] | commenterUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: commenterCreateOrConnectWithoutUtilisateurInput | commenterCreateOrConnectWithoutUtilisateurInput[]
    createMany?: commenterCreateManyUtilisateurInputEnvelope
    connect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SnippetUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<SnippetCreateWithoutUtilisateurInput, SnippetUncheckedCreateWithoutUtilisateurInput> | SnippetCreateWithoutUtilisateurInput[] | SnippetUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: SnippetCreateOrConnectWithoutUtilisateurInput | SnippetCreateOrConnectWithoutUtilisateurInput[]
    upsert?: SnippetUpsertWithWhereUniqueWithoutUtilisateurInput | SnippetUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: SnippetCreateManyUtilisateurInputEnvelope
    set?: SnippetWhereUniqueInput | SnippetWhereUniqueInput[]
    disconnect?: SnippetWhereUniqueInput | SnippetWhereUniqueInput[]
    delete?: SnippetWhereUniqueInput | SnippetWhereUniqueInput[]
    connect?: SnippetWhereUniqueInput | SnippetWhereUniqueInput[]
    update?: SnippetUpdateWithWhereUniqueWithoutUtilisateurInput | SnippetUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: SnippetUpdateManyWithWhereWithoutUtilisateurInput | SnippetUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: SnippetScalarWhereInput | SnippetScalarWhereInput[]
  }

  export type aimerUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<aimerCreateWithoutUtilisateurInput, aimerUncheckedCreateWithoutUtilisateurInput> | aimerCreateWithoutUtilisateurInput[] | aimerUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: aimerCreateOrConnectWithoutUtilisateurInput | aimerCreateOrConnectWithoutUtilisateurInput[]
    upsert?: aimerUpsertWithWhereUniqueWithoutUtilisateurInput | aimerUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: aimerCreateManyUtilisateurInputEnvelope
    set?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    disconnect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    delete?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    connect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    update?: aimerUpdateWithWhereUniqueWithoutUtilisateurInput | aimerUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: aimerUpdateManyWithWhereWithoutUtilisateurInput | aimerUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: aimerScalarWhereInput | aimerScalarWhereInput[]
  }

  export type commenterUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<commenterCreateWithoutUtilisateurInput, commenterUncheckedCreateWithoutUtilisateurInput> | commenterCreateWithoutUtilisateurInput[] | commenterUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: commenterCreateOrConnectWithoutUtilisateurInput | commenterCreateOrConnectWithoutUtilisateurInput[]
    upsert?: commenterUpsertWithWhereUniqueWithoutUtilisateurInput | commenterUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: commenterCreateManyUtilisateurInputEnvelope
    set?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    disconnect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    delete?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    connect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    update?: commenterUpdateWithWhereUniqueWithoutUtilisateurInput | commenterUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: commenterUpdateManyWithWhereWithoutUtilisateurInput | commenterUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: commenterScalarWhereInput | commenterScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SnippetUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<SnippetCreateWithoutUtilisateurInput, SnippetUncheckedCreateWithoutUtilisateurInput> | SnippetCreateWithoutUtilisateurInput[] | SnippetUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: SnippetCreateOrConnectWithoutUtilisateurInput | SnippetCreateOrConnectWithoutUtilisateurInput[]
    upsert?: SnippetUpsertWithWhereUniqueWithoutUtilisateurInput | SnippetUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: SnippetCreateManyUtilisateurInputEnvelope
    set?: SnippetWhereUniqueInput | SnippetWhereUniqueInput[]
    disconnect?: SnippetWhereUniqueInput | SnippetWhereUniqueInput[]
    delete?: SnippetWhereUniqueInput | SnippetWhereUniqueInput[]
    connect?: SnippetWhereUniqueInput | SnippetWhereUniqueInput[]
    update?: SnippetUpdateWithWhereUniqueWithoutUtilisateurInput | SnippetUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: SnippetUpdateManyWithWhereWithoutUtilisateurInput | SnippetUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: SnippetScalarWhereInput | SnippetScalarWhereInput[]
  }

  export type aimerUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<aimerCreateWithoutUtilisateurInput, aimerUncheckedCreateWithoutUtilisateurInput> | aimerCreateWithoutUtilisateurInput[] | aimerUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: aimerCreateOrConnectWithoutUtilisateurInput | aimerCreateOrConnectWithoutUtilisateurInput[]
    upsert?: aimerUpsertWithWhereUniqueWithoutUtilisateurInput | aimerUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: aimerCreateManyUtilisateurInputEnvelope
    set?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    disconnect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    delete?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    connect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    update?: aimerUpdateWithWhereUniqueWithoutUtilisateurInput | aimerUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: aimerUpdateManyWithWhereWithoutUtilisateurInput | aimerUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: aimerScalarWhereInput | aimerScalarWhereInput[]
  }

  export type commenterUncheckedUpdateManyWithoutUtilisateurNestedInput = {
    create?: XOR<commenterCreateWithoutUtilisateurInput, commenterUncheckedCreateWithoutUtilisateurInput> | commenterCreateWithoutUtilisateurInput[] | commenterUncheckedCreateWithoutUtilisateurInput[]
    connectOrCreate?: commenterCreateOrConnectWithoutUtilisateurInput | commenterCreateOrConnectWithoutUtilisateurInput[]
    upsert?: commenterUpsertWithWhereUniqueWithoutUtilisateurInput | commenterUpsertWithWhereUniqueWithoutUtilisateurInput[]
    createMany?: commenterCreateManyUtilisateurInputEnvelope
    set?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    disconnect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    delete?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    connect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    update?: commenterUpdateWithWhereUniqueWithoutUtilisateurInput | commenterUpdateWithWhereUniqueWithoutUtilisateurInput[]
    updateMany?: commenterUpdateManyWithWhereWithoutUtilisateurInput | commenterUpdateManyWithWhereWithoutUtilisateurInput[]
    deleteMany?: commenterScalarWhereInput | commenterScalarWhereInput[]
  }

  export type UtilisateurCreateNestedOneWithoutSnippetsInput = {
    create?: XOR<UtilisateurCreateWithoutSnippetsInput, UtilisateurUncheckedCreateWithoutSnippetsInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutSnippetsInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type aimerCreateNestedManyWithoutSnippetInput = {
    create?: XOR<aimerCreateWithoutSnippetInput, aimerUncheckedCreateWithoutSnippetInput> | aimerCreateWithoutSnippetInput[] | aimerUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: aimerCreateOrConnectWithoutSnippetInput | aimerCreateOrConnectWithoutSnippetInput[]
    createMany?: aimerCreateManySnippetInputEnvelope
    connect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
  }

  export type commenterCreateNestedManyWithoutSnippetInput = {
    create?: XOR<commenterCreateWithoutSnippetInput, commenterUncheckedCreateWithoutSnippetInput> | commenterCreateWithoutSnippetInput[] | commenterUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: commenterCreateOrConnectWithoutSnippetInput | commenterCreateOrConnectWithoutSnippetInput[]
    createMany?: commenterCreateManySnippetInputEnvelope
    connect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
  }

  export type snippetTagCreateNestedManyWithoutSnippetInput = {
    create?: XOR<snippetTagCreateWithoutSnippetInput, snippetTagUncheckedCreateWithoutSnippetInput> | snippetTagCreateWithoutSnippetInput[] | snippetTagUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: snippetTagCreateOrConnectWithoutSnippetInput | snippetTagCreateOrConnectWithoutSnippetInput[]
    createMany?: snippetTagCreateManySnippetInputEnvelope
    connect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
  }

  export type aimerUncheckedCreateNestedManyWithoutSnippetInput = {
    create?: XOR<aimerCreateWithoutSnippetInput, aimerUncheckedCreateWithoutSnippetInput> | aimerCreateWithoutSnippetInput[] | aimerUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: aimerCreateOrConnectWithoutSnippetInput | aimerCreateOrConnectWithoutSnippetInput[]
    createMany?: aimerCreateManySnippetInputEnvelope
    connect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
  }

  export type commenterUncheckedCreateNestedManyWithoutSnippetInput = {
    create?: XOR<commenterCreateWithoutSnippetInput, commenterUncheckedCreateWithoutSnippetInput> | commenterCreateWithoutSnippetInput[] | commenterUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: commenterCreateOrConnectWithoutSnippetInput | commenterCreateOrConnectWithoutSnippetInput[]
    createMany?: commenterCreateManySnippetInputEnvelope
    connect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
  }

  export type snippetTagUncheckedCreateNestedManyWithoutSnippetInput = {
    create?: XOR<snippetTagCreateWithoutSnippetInput, snippetTagUncheckedCreateWithoutSnippetInput> | snippetTagCreateWithoutSnippetInput[] | snippetTagUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: snippetTagCreateOrConnectWithoutSnippetInput | snippetTagCreateOrConnectWithoutSnippetInput[]
    createMany?: snippetTagCreateManySnippetInputEnvelope
    connect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UtilisateurUpdateOneRequiredWithoutSnippetsNestedInput = {
    create?: XOR<UtilisateurCreateWithoutSnippetsInput, UtilisateurUncheckedCreateWithoutSnippetsInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutSnippetsInput
    upsert?: UtilisateurUpsertWithoutSnippetsInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutSnippetsInput, UtilisateurUpdateWithoutSnippetsInput>, UtilisateurUncheckedUpdateWithoutSnippetsInput>
  }

  export type aimerUpdateManyWithoutSnippetNestedInput = {
    create?: XOR<aimerCreateWithoutSnippetInput, aimerUncheckedCreateWithoutSnippetInput> | aimerCreateWithoutSnippetInput[] | aimerUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: aimerCreateOrConnectWithoutSnippetInput | aimerCreateOrConnectWithoutSnippetInput[]
    upsert?: aimerUpsertWithWhereUniqueWithoutSnippetInput | aimerUpsertWithWhereUniqueWithoutSnippetInput[]
    createMany?: aimerCreateManySnippetInputEnvelope
    set?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    disconnect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    delete?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    connect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    update?: aimerUpdateWithWhereUniqueWithoutSnippetInput | aimerUpdateWithWhereUniqueWithoutSnippetInput[]
    updateMany?: aimerUpdateManyWithWhereWithoutSnippetInput | aimerUpdateManyWithWhereWithoutSnippetInput[]
    deleteMany?: aimerScalarWhereInput | aimerScalarWhereInput[]
  }

  export type commenterUpdateManyWithoutSnippetNestedInput = {
    create?: XOR<commenterCreateWithoutSnippetInput, commenterUncheckedCreateWithoutSnippetInput> | commenterCreateWithoutSnippetInput[] | commenterUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: commenterCreateOrConnectWithoutSnippetInput | commenterCreateOrConnectWithoutSnippetInput[]
    upsert?: commenterUpsertWithWhereUniqueWithoutSnippetInput | commenterUpsertWithWhereUniqueWithoutSnippetInput[]
    createMany?: commenterCreateManySnippetInputEnvelope
    set?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    disconnect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    delete?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    connect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    update?: commenterUpdateWithWhereUniqueWithoutSnippetInput | commenterUpdateWithWhereUniqueWithoutSnippetInput[]
    updateMany?: commenterUpdateManyWithWhereWithoutSnippetInput | commenterUpdateManyWithWhereWithoutSnippetInput[]
    deleteMany?: commenterScalarWhereInput | commenterScalarWhereInput[]
  }

  export type snippetTagUpdateManyWithoutSnippetNestedInput = {
    create?: XOR<snippetTagCreateWithoutSnippetInput, snippetTagUncheckedCreateWithoutSnippetInput> | snippetTagCreateWithoutSnippetInput[] | snippetTagUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: snippetTagCreateOrConnectWithoutSnippetInput | snippetTagCreateOrConnectWithoutSnippetInput[]
    upsert?: snippetTagUpsertWithWhereUniqueWithoutSnippetInput | snippetTagUpsertWithWhereUniqueWithoutSnippetInput[]
    createMany?: snippetTagCreateManySnippetInputEnvelope
    set?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    disconnect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    delete?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    connect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    update?: snippetTagUpdateWithWhereUniqueWithoutSnippetInput | snippetTagUpdateWithWhereUniqueWithoutSnippetInput[]
    updateMany?: snippetTagUpdateManyWithWhereWithoutSnippetInput | snippetTagUpdateManyWithWhereWithoutSnippetInput[]
    deleteMany?: snippetTagScalarWhereInput | snippetTagScalarWhereInput[]
  }

  export type aimerUncheckedUpdateManyWithoutSnippetNestedInput = {
    create?: XOR<aimerCreateWithoutSnippetInput, aimerUncheckedCreateWithoutSnippetInput> | aimerCreateWithoutSnippetInput[] | aimerUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: aimerCreateOrConnectWithoutSnippetInput | aimerCreateOrConnectWithoutSnippetInput[]
    upsert?: aimerUpsertWithWhereUniqueWithoutSnippetInput | aimerUpsertWithWhereUniqueWithoutSnippetInput[]
    createMany?: aimerCreateManySnippetInputEnvelope
    set?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    disconnect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    delete?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    connect?: aimerWhereUniqueInput | aimerWhereUniqueInput[]
    update?: aimerUpdateWithWhereUniqueWithoutSnippetInput | aimerUpdateWithWhereUniqueWithoutSnippetInput[]
    updateMany?: aimerUpdateManyWithWhereWithoutSnippetInput | aimerUpdateManyWithWhereWithoutSnippetInput[]
    deleteMany?: aimerScalarWhereInput | aimerScalarWhereInput[]
  }

  export type commenterUncheckedUpdateManyWithoutSnippetNestedInput = {
    create?: XOR<commenterCreateWithoutSnippetInput, commenterUncheckedCreateWithoutSnippetInput> | commenterCreateWithoutSnippetInput[] | commenterUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: commenterCreateOrConnectWithoutSnippetInput | commenterCreateOrConnectWithoutSnippetInput[]
    upsert?: commenterUpsertWithWhereUniqueWithoutSnippetInput | commenterUpsertWithWhereUniqueWithoutSnippetInput[]
    createMany?: commenterCreateManySnippetInputEnvelope
    set?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    disconnect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    delete?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    connect?: commenterWhereUniqueInput | commenterWhereUniqueInput[]
    update?: commenterUpdateWithWhereUniqueWithoutSnippetInput | commenterUpdateWithWhereUniqueWithoutSnippetInput[]
    updateMany?: commenterUpdateManyWithWhereWithoutSnippetInput | commenterUpdateManyWithWhereWithoutSnippetInput[]
    deleteMany?: commenterScalarWhereInput | commenterScalarWhereInput[]
  }

  export type snippetTagUncheckedUpdateManyWithoutSnippetNestedInput = {
    create?: XOR<snippetTagCreateWithoutSnippetInput, snippetTagUncheckedCreateWithoutSnippetInput> | snippetTagCreateWithoutSnippetInput[] | snippetTagUncheckedCreateWithoutSnippetInput[]
    connectOrCreate?: snippetTagCreateOrConnectWithoutSnippetInput | snippetTagCreateOrConnectWithoutSnippetInput[]
    upsert?: snippetTagUpsertWithWhereUniqueWithoutSnippetInput | snippetTagUpsertWithWhereUniqueWithoutSnippetInput[]
    createMany?: snippetTagCreateManySnippetInputEnvelope
    set?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    disconnect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    delete?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    connect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    update?: snippetTagUpdateWithWhereUniqueWithoutSnippetInput | snippetTagUpdateWithWhereUniqueWithoutSnippetInput[]
    updateMany?: snippetTagUpdateManyWithWhereWithoutSnippetInput | snippetTagUpdateManyWithWhereWithoutSnippetInput[]
    deleteMany?: snippetTagScalarWhereInput | snippetTagScalarWhereInput[]
  }

  export type snippetTagCreateNestedManyWithoutTagInput = {
    create?: XOR<snippetTagCreateWithoutTagInput, snippetTagUncheckedCreateWithoutTagInput> | snippetTagCreateWithoutTagInput[] | snippetTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: snippetTagCreateOrConnectWithoutTagInput | snippetTagCreateOrConnectWithoutTagInput[]
    createMany?: snippetTagCreateManyTagInputEnvelope
    connect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
  }

  export type snippetTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<snippetTagCreateWithoutTagInput, snippetTagUncheckedCreateWithoutTagInput> | snippetTagCreateWithoutTagInput[] | snippetTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: snippetTagCreateOrConnectWithoutTagInput | snippetTagCreateOrConnectWithoutTagInput[]
    createMany?: snippetTagCreateManyTagInputEnvelope
    connect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
  }

  export type snippetTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<snippetTagCreateWithoutTagInput, snippetTagUncheckedCreateWithoutTagInput> | snippetTagCreateWithoutTagInput[] | snippetTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: snippetTagCreateOrConnectWithoutTagInput | snippetTagCreateOrConnectWithoutTagInput[]
    upsert?: snippetTagUpsertWithWhereUniqueWithoutTagInput | snippetTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: snippetTagCreateManyTagInputEnvelope
    set?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    disconnect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    delete?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    connect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    update?: snippetTagUpdateWithWhereUniqueWithoutTagInput | snippetTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: snippetTagUpdateManyWithWhereWithoutTagInput | snippetTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: snippetTagScalarWhereInput | snippetTagScalarWhereInput[]
  }

  export type snippetTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<snippetTagCreateWithoutTagInput, snippetTagUncheckedCreateWithoutTagInput> | snippetTagCreateWithoutTagInput[] | snippetTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: snippetTagCreateOrConnectWithoutTagInput | snippetTagCreateOrConnectWithoutTagInput[]
    upsert?: snippetTagUpsertWithWhereUniqueWithoutTagInput | snippetTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: snippetTagCreateManyTagInputEnvelope
    set?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    disconnect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    delete?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    connect?: snippetTagWhereUniqueInput | snippetTagWhereUniqueInput[]
    update?: snippetTagUpdateWithWhereUniqueWithoutTagInput | snippetTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: snippetTagUpdateManyWithWhereWithoutTagInput | snippetTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: snippetTagScalarWhereInput | snippetTagScalarWhereInput[]
  }

  export type UtilisateurCreateNestedOneWithoutAimerInput = {
    create?: XOR<UtilisateurCreateWithoutAimerInput, UtilisateurUncheckedCreateWithoutAimerInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutAimerInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type SnippetCreateNestedOneWithoutAimerInput = {
    create?: XOR<SnippetCreateWithoutAimerInput, SnippetUncheckedCreateWithoutAimerInput>
    connectOrCreate?: SnippetCreateOrConnectWithoutAimerInput
    connect?: SnippetWhereUniqueInput
  }

  export type UtilisateurUpdateOneRequiredWithoutAimerNestedInput = {
    create?: XOR<UtilisateurCreateWithoutAimerInput, UtilisateurUncheckedCreateWithoutAimerInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutAimerInput
    upsert?: UtilisateurUpsertWithoutAimerInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutAimerInput, UtilisateurUpdateWithoutAimerInput>, UtilisateurUncheckedUpdateWithoutAimerInput>
  }

  export type SnippetUpdateOneRequiredWithoutAimerNestedInput = {
    create?: XOR<SnippetCreateWithoutAimerInput, SnippetUncheckedCreateWithoutAimerInput>
    connectOrCreate?: SnippetCreateOrConnectWithoutAimerInput
    upsert?: SnippetUpsertWithoutAimerInput
    connect?: SnippetWhereUniqueInput
    update?: XOR<XOR<SnippetUpdateToOneWithWhereWithoutAimerInput, SnippetUpdateWithoutAimerInput>, SnippetUncheckedUpdateWithoutAimerInput>
  }

  export type UtilisateurCreateNestedOneWithoutCommenterInput = {
    create?: XOR<UtilisateurCreateWithoutCommenterInput, UtilisateurUncheckedCreateWithoutCommenterInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutCommenterInput
    connect?: UtilisateurWhereUniqueInput
  }

  export type SnippetCreateNestedOneWithoutCommenterInput = {
    create?: XOR<SnippetCreateWithoutCommenterInput, SnippetUncheckedCreateWithoutCommenterInput>
    connectOrCreate?: SnippetCreateOrConnectWithoutCommenterInput
    connect?: SnippetWhereUniqueInput
  }

  export type UtilisateurUpdateOneRequiredWithoutCommenterNestedInput = {
    create?: XOR<UtilisateurCreateWithoutCommenterInput, UtilisateurUncheckedCreateWithoutCommenterInput>
    connectOrCreate?: UtilisateurCreateOrConnectWithoutCommenterInput
    upsert?: UtilisateurUpsertWithoutCommenterInput
    connect?: UtilisateurWhereUniqueInput
    update?: XOR<XOR<UtilisateurUpdateToOneWithWhereWithoutCommenterInput, UtilisateurUpdateWithoutCommenterInput>, UtilisateurUncheckedUpdateWithoutCommenterInput>
  }

  export type SnippetUpdateOneRequiredWithoutCommenterNestedInput = {
    create?: XOR<SnippetCreateWithoutCommenterInput, SnippetUncheckedCreateWithoutCommenterInput>
    connectOrCreate?: SnippetCreateOrConnectWithoutCommenterInput
    upsert?: SnippetUpsertWithoutCommenterInput
    connect?: SnippetWhereUniqueInput
    update?: XOR<XOR<SnippetUpdateToOneWithWhereWithoutCommenterInput, SnippetUpdateWithoutCommenterInput>, SnippetUncheckedUpdateWithoutCommenterInput>
  }

  export type SnippetCreateNestedOneWithoutSnippetTagInput = {
    create?: XOR<SnippetCreateWithoutSnippetTagInput, SnippetUncheckedCreateWithoutSnippetTagInput>
    connectOrCreate?: SnippetCreateOrConnectWithoutSnippetTagInput
    connect?: SnippetWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutSnippetTagInput = {
    create?: XOR<TagCreateWithoutSnippetTagInput, TagUncheckedCreateWithoutSnippetTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutSnippetTagInput
    connect?: TagWhereUniqueInput
  }

  export type SnippetUpdateOneRequiredWithoutSnippetTagNestedInput = {
    create?: XOR<SnippetCreateWithoutSnippetTagInput, SnippetUncheckedCreateWithoutSnippetTagInput>
    connectOrCreate?: SnippetCreateOrConnectWithoutSnippetTagInput
    upsert?: SnippetUpsertWithoutSnippetTagInput
    connect?: SnippetWhereUniqueInput
    update?: XOR<XOR<SnippetUpdateToOneWithWhereWithoutSnippetTagInput, SnippetUpdateWithoutSnippetTagInput>, SnippetUncheckedUpdateWithoutSnippetTagInput>
  }

  export type TagUpdateOneRequiredWithoutSnippetTagNestedInput = {
    create?: XOR<TagCreateWithoutSnippetTagInput, TagUncheckedCreateWithoutSnippetTagInput>
    connectOrCreate?: TagCreateOrConnectWithoutSnippetTagInput
    upsert?: TagUpsertWithoutSnippetTagInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutSnippetTagInput, TagUpdateWithoutSnippetTagInput>, TagUncheckedUpdateWithoutSnippetTagInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SnippetCreateWithoutUtilisateurInput = {
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    aimer?: aimerCreateNestedManyWithoutSnippetInput
    commenter?: commenterCreateNestedManyWithoutSnippetInput
    snippetTag?: snippetTagCreateNestedManyWithoutSnippetInput
  }

  export type SnippetUncheckedCreateWithoutUtilisateurInput = {
    identifiant_snippet?: number
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    aimer?: aimerUncheckedCreateNestedManyWithoutSnippetInput
    commenter?: commenterUncheckedCreateNestedManyWithoutSnippetInput
    snippetTag?: snippetTagUncheckedCreateNestedManyWithoutSnippetInput
  }

  export type SnippetCreateOrConnectWithoutUtilisateurInput = {
    where: SnippetWhereUniqueInput
    create: XOR<SnippetCreateWithoutUtilisateurInput, SnippetUncheckedCreateWithoutUtilisateurInput>
  }

  export type SnippetCreateManyUtilisateurInputEnvelope = {
    data: SnippetCreateManyUtilisateurInput | SnippetCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type aimerCreateWithoutUtilisateurInput = {
    snippet: SnippetCreateNestedOneWithoutAimerInput
  }

  export type aimerUncheckedCreateWithoutUtilisateurInput = {
    identifiant_snippet: number
  }

  export type aimerCreateOrConnectWithoutUtilisateurInput = {
    where: aimerWhereUniqueInput
    create: XOR<aimerCreateWithoutUtilisateurInput, aimerUncheckedCreateWithoutUtilisateurInput>
  }

  export type aimerCreateManyUtilisateurInputEnvelope = {
    data: aimerCreateManyUtilisateurInput | aimerCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type commenterCreateWithoutUtilisateurInput = {
    date_?: Date | string
    texte?: string | null
    snippet: SnippetCreateNestedOneWithoutCommenterInput
  }

  export type commenterUncheckedCreateWithoutUtilisateurInput = {
    identifiant_snippet: number
    date_?: Date | string
    texte?: string | null
  }

  export type commenterCreateOrConnectWithoutUtilisateurInput = {
    where: commenterWhereUniqueInput
    create: XOR<commenterCreateWithoutUtilisateurInput, commenterUncheckedCreateWithoutUtilisateurInput>
  }

  export type commenterCreateManyUtilisateurInputEnvelope = {
    data: commenterCreateManyUtilisateurInput | commenterCreateManyUtilisateurInput[]
    skipDuplicates?: boolean
  }

  export type SnippetUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: SnippetWhereUniqueInput
    update: XOR<SnippetUpdateWithoutUtilisateurInput, SnippetUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<SnippetCreateWithoutUtilisateurInput, SnippetUncheckedCreateWithoutUtilisateurInput>
  }

  export type SnippetUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: SnippetWhereUniqueInput
    data: XOR<SnippetUpdateWithoutUtilisateurInput, SnippetUncheckedUpdateWithoutUtilisateurInput>
  }

  export type SnippetUpdateManyWithWhereWithoutUtilisateurInput = {
    where: SnippetScalarWhereInput
    data: XOR<SnippetUpdateManyMutationInput, SnippetUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type SnippetScalarWhereInput = {
    AND?: SnippetScalarWhereInput | SnippetScalarWhereInput[]
    OR?: SnippetScalarWhereInput[]
    NOT?: SnippetScalarWhereInput | SnippetScalarWhereInput[]
    identifiant_snippet?: IntFilter<"Snippet"> | number
    titre?: StringNullableFilter<"Snippet"> | string | null
    code?: StringNullableFilter<"Snippet"> | string | null
    langage?: StringNullableFilter<"Snippet"> | string | null
    visibilite?: StringNullableFilter<"Snippet"> | string | null
    creer_le?: DateTimeFilter<"Snippet"> | Date | string
    identifiant_utilisateur?: IntFilter<"Snippet"> | number
  }

  export type aimerUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: aimerWhereUniqueInput
    update: XOR<aimerUpdateWithoutUtilisateurInput, aimerUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<aimerCreateWithoutUtilisateurInput, aimerUncheckedCreateWithoutUtilisateurInput>
  }

  export type aimerUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: aimerWhereUniqueInput
    data: XOR<aimerUpdateWithoutUtilisateurInput, aimerUncheckedUpdateWithoutUtilisateurInput>
  }

  export type aimerUpdateManyWithWhereWithoutUtilisateurInput = {
    where: aimerScalarWhereInput
    data: XOR<aimerUpdateManyMutationInput, aimerUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type aimerScalarWhereInput = {
    AND?: aimerScalarWhereInput | aimerScalarWhereInput[]
    OR?: aimerScalarWhereInput[]
    NOT?: aimerScalarWhereInput | aimerScalarWhereInput[]
    identifiant_utilisateur?: IntFilter<"aimer"> | number
    identifiant_snippet?: IntFilter<"aimer"> | number
  }

  export type commenterUpsertWithWhereUniqueWithoutUtilisateurInput = {
    where: commenterWhereUniqueInput
    update: XOR<commenterUpdateWithoutUtilisateurInput, commenterUncheckedUpdateWithoutUtilisateurInput>
    create: XOR<commenterCreateWithoutUtilisateurInput, commenterUncheckedCreateWithoutUtilisateurInput>
  }

  export type commenterUpdateWithWhereUniqueWithoutUtilisateurInput = {
    where: commenterWhereUniqueInput
    data: XOR<commenterUpdateWithoutUtilisateurInput, commenterUncheckedUpdateWithoutUtilisateurInput>
  }

  export type commenterUpdateManyWithWhereWithoutUtilisateurInput = {
    where: commenterScalarWhereInput
    data: XOR<commenterUpdateManyMutationInput, commenterUncheckedUpdateManyWithoutUtilisateurInput>
  }

  export type commenterScalarWhereInput = {
    AND?: commenterScalarWhereInput | commenterScalarWhereInput[]
    OR?: commenterScalarWhereInput[]
    NOT?: commenterScalarWhereInput | commenterScalarWhereInput[]
    identifiant_utilisateur?: IntFilter<"commenter"> | number
    identifiant_snippet?: IntFilter<"commenter"> | number
    date_?: DateTimeFilter<"commenter"> | Date | string
    texte?: StringNullableFilter<"commenter"> | string | null
  }

  export type UtilisateurCreateWithoutSnippetsInput = {
    email: string
    motdepasse_hash: string
    creer_le?: Date | string
    aimer?: aimerCreateNestedManyWithoutUtilisateurInput
    commenter?: commenterCreateNestedManyWithoutUtilisateurInput
  }

  export type UtilisateurUncheckedCreateWithoutSnippetsInput = {
    identifiant_utilisateur?: number
    email: string
    motdepasse_hash: string
    creer_le?: Date | string
    aimer?: aimerUncheckedCreateNestedManyWithoutUtilisateurInput
    commenter?: commenterUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type UtilisateurCreateOrConnectWithoutSnippetsInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutSnippetsInput, UtilisateurUncheckedCreateWithoutSnippetsInput>
  }

  export type aimerCreateWithoutSnippetInput = {
    utilisateur: UtilisateurCreateNestedOneWithoutAimerInput
  }

  export type aimerUncheckedCreateWithoutSnippetInput = {
    identifiant_utilisateur: number
  }

  export type aimerCreateOrConnectWithoutSnippetInput = {
    where: aimerWhereUniqueInput
    create: XOR<aimerCreateWithoutSnippetInput, aimerUncheckedCreateWithoutSnippetInput>
  }

  export type aimerCreateManySnippetInputEnvelope = {
    data: aimerCreateManySnippetInput | aimerCreateManySnippetInput[]
    skipDuplicates?: boolean
  }

  export type commenterCreateWithoutSnippetInput = {
    date_?: Date | string
    texte?: string | null
    utilisateur: UtilisateurCreateNestedOneWithoutCommenterInput
  }

  export type commenterUncheckedCreateWithoutSnippetInput = {
    identifiant_utilisateur: number
    date_?: Date | string
    texte?: string | null
  }

  export type commenterCreateOrConnectWithoutSnippetInput = {
    where: commenterWhereUniqueInput
    create: XOR<commenterCreateWithoutSnippetInput, commenterUncheckedCreateWithoutSnippetInput>
  }

  export type commenterCreateManySnippetInputEnvelope = {
    data: commenterCreateManySnippetInput | commenterCreateManySnippetInput[]
    skipDuplicates?: boolean
  }

  export type snippetTagCreateWithoutSnippetInput = {
    tag: TagCreateNestedOneWithoutSnippetTagInput
  }

  export type snippetTagUncheckedCreateWithoutSnippetInput = {
    tagId: number
  }

  export type snippetTagCreateOrConnectWithoutSnippetInput = {
    where: snippetTagWhereUniqueInput
    create: XOR<snippetTagCreateWithoutSnippetInput, snippetTagUncheckedCreateWithoutSnippetInput>
  }

  export type snippetTagCreateManySnippetInputEnvelope = {
    data: snippetTagCreateManySnippetInput | snippetTagCreateManySnippetInput[]
    skipDuplicates?: boolean
  }

  export type UtilisateurUpsertWithoutSnippetsInput = {
    update: XOR<UtilisateurUpdateWithoutSnippetsInput, UtilisateurUncheckedUpdateWithoutSnippetsInput>
    create: XOR<UtilisateurCreateWithoutSnippetsInput, UtilisateurUncheckedCreateWithoutSnippetsInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutSnippetsInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutSnippetsInput, UtilisateurUncheckedUpdateWithoutSnippetsInput>
  }

  export type UtilisateurUpdateWithoutSnippetsInput = {
    email?: StringFieldUpdateOperationsInput | string
    motdepasse_hash?: StringFieldUpdateOperationsInput | string
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    aimer?: aimerUpdateManyWithoutUtilisateurNestedInput
    commenter?: commenterUpdateManyWithoutUtilisateurNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutSnippetsInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    motdepasse_hash?: StringFieldUpdateOperationsInput | string
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    aimer?: aimerUncheckedUpdateManyWithoutUtilisateurNestedInput
    commenter?: commenterUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type aimerUpsertWithWhereUniqueWithoutSnippetInput = {
    where: aimerWhereUniqueInput
    update: XOR<aimerUpdateWithoutSnippetInput, aimerUncheckedUpdateWithoutSnippetInput>
    create: XOR<aimerCreateWithoutSnippetInput, aimerUncheckedCreateWithoutSnippetInput>
  }

  export type aimerUpdateWithWhereUniqueWithoutSnippetInput = {
    where: aimerWhereUniqueInput
    data: XOR<aimerUpdateWithoutSnippetInput, aimerUncheckedUpdateWithoutSnippetInput>
  }

  export type aimerUpdateManyWithWhereWithoutSnippetInput = {
    where: aimerScalarWhereInput
    data: XOR<aimerUpdateManyMutationInput, aimerUncheckedUpdateManyWithoutSnippetInput>
  }

  export type commenterUpsertWithWhereUniqueWithoutSnippetInput = {
    where: commenterWhereUniqueInput
    update: XOR<commenterUpdateWithoutSnippetInput, commenterUncheckedUpdateWithoutSnippetInput>
    create: XOR<commenterCreateWithoutSnippetInput, commenterUncheckedCreateWithoutSnippetInput>
  }

  export type commenterUpdateWithWhereUniqueWithoutSnippetInput = {
    where: commenterWhereUniqueInput
    data: XOR<commenterUpdateWithoutSnippetInput, commenterUncheckedUpdateWithoutSnippetInput>
  }

  export type commenterUpdateManyWithWhereWithoutSnippetInput = {
    where: commenterScalarWhereInput
    data: XOR<commenterUpdateManyMutationInput, commenterUncheckedUpdateManyWithoutSnippetInput>
  }

  export type snippetTagUpsertWithWhereUniqueWithoutSnippetInput = {
    where: snippetTagWhereUniqueInput
    update: XOR<snippetTagUpdateWithoutSnippetInput, snippetTagUncheckedUpdateWithoutSnippetInput>
    create: XOR<snippetTagCreateWithoutSnippetInput, snippetTagUncheckedCreateWithoutSnippetInput>
  }

  export type snippetTagUpdateWithWhereUniqueWithoutSnippetInput = {
    where: snippetTagWhereUniqueInput
    data: XOR<snippetTagUpdateWithoutSnippetInput, snippetTagUncheckedUpdateWithoutSnippetInput>
  }

  export type snippetTagUpdateManyWithWhereWithoutSnippetInput = {
    where: snippetTagScalarWhereInput
    data: XOR<snippetTagUpdateManyMutationInput, snippetTagUncheckedUpdateManyWithoutSnippetInput>
  }

  export type snippetTagScalarWhereInput = {
    AND?: snippetTagScalarWhereInput | snippetTagScalarWhereInput[]
    OR?: snippetTagScalarWhereInput[]
    NOT?: snippetTagScalarWhereInput | snippetTagScalarWhereInput[]
    snippetId?: IntFilter<"snippetTag"> | number
    tagId?: IntFilter<"snippetTag"> | number
  }

  export type snippetTagCreateWithoutTagInput = {
    snippet: SnippetCreateNestedOneWithoutSnippetTagInput
  }

  export type snippetTagUncheckedCreateWithoutTagInput = {
    snippetId: number
  }

  export type snippetTagCreateOrConnectWithoutTagInput = {
    where: snippetTagWhereUniqueInput
    create: XOR<snippetTagCreateWithoutTagInput, snippetTagUncheckedCreateWithoutTagInput>
  }

  export type snippetTagCreateManyTagInputEnvelope = {
    data: snippetTagCreateManyTagInput | snippetTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type snippetTagUpsertWithWhereUniqueWithoutTagInput = {
    where: snippetTagWhereUniqueInput
    update: XOR<snippetTagUpdateWithoutTagInput, snippetTagUncheckedUpdateWithoutTagInput>
    create: XOR<snippetTagCreateWithoutTagInput, snippetTagUncheckedCreateWithoutTagInput>
  }

  export type snippetTagUpdateWithWhereUniqueWithoutTagInput = {
    where: snippetTagWhereUniqueInput
    data: XOR<snippetTagUpdateWithoutTagInput, snippetTagUncheckedUpdateWithoutTagInput>
  }

  export type snippetTagUpdateManyWithWhereWithoutTagInput = {
    where: snippetTagScalarWhereInput
    data: XOR<snippetTagUpdateManyMutationInput, snippetTagUncheckedUpdateManyWithoutTagInput>
  }

  export type UtilisateurCreateWithoutAimerInput = {
    email: string
    motdepasse_hash: string
    creer_le?: Date | string
    snippets?: SnippetCreateNestedManyWithoutUtilisateurInput
    commenter?: commenterCreateNestedManyWithoutUtilisateurInput
  }

  export type UtilisateurUncheckedCreateWithoutAimerInput = {
    identifiant_utilisateur?: number
    email: string
    motdepasse_hash: string
    creer_le?: Date | string
    snippets?: SnippetUncheckedCreateNestedManyWithoutUtilisateurInput
    commenter?: commenterUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type UtilisateurCreateOrConnectWithoutAimerInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutAimerInput, UtilisateurUncheckedCreateWithoutAimerInput>
  }

  export type SnippetCreateWithoutAimerInput = {
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutSnippetsInput
    commenter?: commenterCreateNestedManyWithoutSnippetInput
    snippetTag?: snippetTagCreateNestedManyWithoutSnippetInput
  }

  export type SnippetUncheckedCreateWithoutAimerInput = {
    identifiant_snippet?: number
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    identifiant_utilisateur: number
    commenter?: commenterUncheckedCreateNestedManyWithoutSnippetInput
    snippetTag?: snippetTagUncheckedCreateNestedManyWithoutSnippetInput
  }

  export type SnippetCreateOrConnectWithoutAimerInput = {
    where: SnippetWhereUniqueInput
    create: XOR<SnippetCreateWithoutAimerInput, SnippetUncheckedCreateWithoutAimerInput>
  }

  export type UtilisateurUpsertWithoutAimerInput = {
    update: XOR<UtilisateurUpdateWithoutAimerInput, UtilisateurUncheckedUpdateWithoutAimerInput>
    create: XOR<UtilisateurCreateWithoutAimerInput, UtilisateurUncheckedCreateWithoutAimerInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutAimerInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutAimerInput, UtilisateurUncheckedUpdateWithoutAimerInput>
  }

  export type UtilisateurUpdateWithoutAimerInput = {
    email?: StringFieldUpdateOperationsInput | string
    motdepasse_hash?: StringFieldUpdateOperationsInput | string
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    snippets?: SnippetUpdateManyWithoutUtilisateurNestedInput
    commenter?: commenterUpdateManyWithoutUtilisateurNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutAimerInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    motdepasse_hash?: StringFieldUpdateOperationsInput | string
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    snippets?: SnippetUncheckedUpdateManyWithoutUtilisateurNestedInput
    commenter?: commenterUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type SnippetUpsertWithoutAimerInput = {
    update: XOR<SnippetUpdateWithoutAimerInput, SnippetUncheckedUpdateWithoutAimerInput>
    create: XOR<SnippetCreateWithoutAimerInput, SnippetUncheckedCreateWithoutAimerInput>
    where?: SnippetWhereInput
  }

  export type SnippetUpdateToOneWithWhereWithoutAimerInput = {
    where?: SnippetWhereInput
    data: XOR<SnippetUpdateWithoutAimerInput, SnippetUncheckedUpdateWithoutAimerInput>
  }

  export type SnippetUpdateWithoutAimerInput = {
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutSnippetsNestedInput
    commenter?: commenterUpdateManyWithoutSnippetNestedInput
    snippetTag?: snippetTagUpdateManyWithoutSnippetNestedInput
  }

  export type SnippetUncheckedUpdateWithoutAimerInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    commenter?: commenterUncheckedUpdateManyWithoutSnippetNestedInput
    snippetTag?: snippetTagUncheckedUpdateManyWithoutSnippetNestedInput
  }

  export type UtilisateurCreateWithoutCommenterInput = {
    email: string
    motdepasse_hash: string
    creer_le?: Date | string
    snippets?: SnippetCreateNestedManyWithoutUtilisateurInput
    aimer?: aimerCreateNestedManyWithoutUtilisateurInput
  }

  export type UtilisateurUncheckedCreateWithoutCommenterInput = {
    identifiant_utilisateur?: number
    email: string
    motdepasse_hash: string
    creer_le?: Date | string
    snippets?: SnippetUncheckedCreateNestedManyWithoutUtilisateurInput
    aimer?: aimerUncheckedCreateNestedManyWithoutUtilisateurInput
  }

  export type UtilisateurCreateOrConnectWithoutCommenterInput = {
    where: UtilisateurWhereUniqueInput
    create: XOR<UtilisateurCreateWithoutCommenterInput, UtilisateurUncheckedCreateWithoutCommenterInput>
  }

  export type SnippetCreateWithoutCommenterInput = {
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutSnippetsInput
    aimer?: aimerCreateNestedManyWithoutSnippetInput
    snippetTag?: snippetTagCreateNestedManyWithoutSnippetInput
  }

  export type SnippetUncheckedCreateWithoutCommenterInput = {
    identifiant_snippet?: number
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    identifiant_utilisateur: number
    aimer?: aimerUncheckedCreateNestedManyWithoutSnippetInput
    snippetTag?: snippetTagUncheckedCreateNestedManyWithoutSnippetInput
  }

  export type SnippetCreateOrConnectWithoutCommenterInput = {
    where: SnippetWhereUniqueInput
    create: XOR<SnippetCreateWithoutCommenterInput, SnippetUncheckedCreateWithoutCommenterInput>
  }

  export type UtilisateurUpsertWithoutCommenterInput = {
    update: XOR<UtilisateurUpdateWithoutCommenterInput, UtilisateurUncheckedUpdateWithoutCommenterInput>
    create: XOR<UtilisateurCreateWithoutCommenterInput, UtilisateurUncheckedCreateWithoutCommenterInput>
    where?: UtilisateurWhereInput
  }

  export type UtilisateurUpdateToOneWithWhereWithoutCommenterInput = {
    where?: UtilisateurWhereInput
    data: XOR<UtilisateurUpdateWithoutCommenterInput, UtilisateurUncheckedUpdateWithoutCommenterInput>
  }

  export type UtilisateurUpdateWithoutCommenterInput = {
    email?: StringFieldUpdateOperationsInput | string
    motdepasse_hash?: StringFieldUpdateOperationsInput | string
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    snippets?: SnippetUpdateManyWithoutUtilisateurNestedInput
    aimer?: aimerUpdateManyWithoutUtilisateurNestedInput
  }

  export type UtilisateurUncheckedUpdateWithoutCommenterInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    motdepasse_hash?: StringFieldUpdateOperationsInput | string
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    snippets?: SnippetUncheckedUpdateManyWithoutUtilisateurNestedInput
    aimer?: aimerUncheckedUpdateManyWithoutUtilisateurNestedInput
  }

  export type SnippetUpsertWithoutCommenterInput = {
    update: XOR<SnippetUpdateWithoutCommenterInput, SnippetUncheckedUpdateWithoutCommenterInput>
    create: XOR<SnippetCreateWithoutCommenterInput, SnippetUncheckedCreateWithoutCommenterInput>
    where?: SnippetWhereInput
  }

  export type SnippetUpdateToOneWithWhereWithoutCommenterInput = {
    where?: SnippetWhereInput
    data: XOR<SnippetUpdateWithoutCommenterInput, SnippetUncheckedUpdateWithoutCommenterInput>
  }

  export type SnippetUpdateWithoutCommenterInput = {
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutSnippetsNestedInput
    aimer?: aimerUpdateManyWithoutSnippetNestedInput
    snippetTag?: snippetTagUpdateManyWithoutSnippetNestedInput
  }

  export type SnippetUncheckedUpdateWithoutCommenterInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    aimer?: aimerUncheckedUpdateManyWithoutSnippetNestedInput
    snippetTag?: snippetTagUncheckedUpdateManyWithoutSnippetNestedInput
  }

  export type SnippetCreateWithoutSnippetTagInput = {
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    utilisateur: UtilisateurCreateNestedOneWithoutSnippetsInput
    aimer?: aimerCreateNestedManyWithoutSnippetInput
    commenter?: commenterCreateNestedManyWithoutSnippetInput
  }

  export type SnippetUncheckedCreateWithoutSnippetTagInput = {
    identifiant_snippet?: number
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
    identifiant_utilisateur: number
    aimer?: aimerUncheckedCreateNestedManyWithoutSnippetInput
    commenter?: commenterUncheckedCreateNestedManyWithoutSnippetInput
  }

  export type SnippetCreateOrConnectWithoutSnippetTagInput = {
    where: SnippetWhereUniqueInput
    create: XOR<SnippetCreateWithoutSnippetTagInput, SnippetUncheckedCreateWithoutSnippetTagInput>
  }

  export type TagCreateWithoutSnippetTagInput = {
    name: string
  }

  export type TagUncheckedCreateWithoutSnippetTagInput = {
    identifiant_tag?: number
    name: string
  }

  export type TagCreateOrConnectWithoutSnippetTagInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutSnippetTagInput, TagUncheckedCreateWithoutSnippetTagInput>
  }

  export type SnippetUpsertWithoutSnippetTagInput = {
    update: XOR<SnippetUpdateWithoutSnippetTagInput, SnippetUncheckedUpdateWithoutSnippetTagInput>
    create: XOR<SnippetCreateWithoutSnippetTagInput, SnippetUncheckedCreateWithoutSnippetTagInput>
    where?: SnippetWhereInput
  }

  export type SnippetUpdateToOneWithWhereWithoutSnippetTagInput = {
    where?: SnippetWhereInput
    data: XOR<SnippetUpdateWithoutSnippetTagInput, SnippetUncheckedUpdateWithoutSnippetTagInput>
  }

  export type SnippetUpdateWithoutSnippetTagInput = {
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    utilisateur?: UtilisateurUpdateOneRequiredWithoutSnippetsNestedInput
    aimer?: aimerUpdateManyWithoutSnippetNestedInput
    commenter?: commenterUpdateManyWithoutSnippetNestedInput
  }

  export type SnippetUncheckedUpdateWithoutSnippetTagInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    aimer?: aimerUncheckedUpdateManyWithoutSnippetNestedInput
    commenter?: commenterUncheckedUpdateManyWithoutSnippetNestedInput
  }

  export type TagUpsertWithoutSnippetTagInput = {
    update: XOR<TagUpdateWithoutSnippetTagInput, TagUncheckedUpdateWithoutSnippetTagInput>
    create: XOR<TagCreateWithoutSnippetTagInput, TagUncheckedCreateWithoutSnippetTagInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutSnippetTagInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutSnippetTagInput, TagUncheckedUpdateWithoutSnippetTagInput>
  }

  export type TagUpdateWithoutSnippetTagInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutSnippetTagInput = {
    identifiant_tag?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SnippetCreateManyUtilisateurInput = {
    identifiant_snippet?: number
    titre?: string | null
    code?: string | null
    langage?: string | null
    visibilite?: string | null
    creer_le?: Date | string
  }

  export type aimerCreateManyUtilisateurInput = {
    identifiant_snippet: number
  }

  export type commenterCreateManyUtilisateurInput = {
    identifiant_snippet: number
    date_?: Date | string
    texte?: string | null
  }

  export type SnippetUpdateWithoutUtilisateurInput = {
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    aimer?: aimerUpdateManyWithoutSnippetNestedInput
    commenter?: commenterUpdateManyWithoutSnippetNestedInput
    snippetTag?: snippetTagUpdateManyWithoutSnippetNestedInput
  }

  export type SnippetUncheckedUpdateWithoutUtilisateurInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
    aimer?: aimerUncheckedUpdateManyWithoutSnippetNestedInput
    commenter?: commenterUncheckedUpdateManyWithoutSnippetNestedInput
    snippetTag?: snippetTagUncheckedUpdateManyWithoutSnippetNestedInput
  }

  export type SnippetUncheckedUpdateManyWithoutUtilisateurInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    titre?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    langage?: NullableStringFieldUpdateOperationsInput | string | null
    visibilite?: NullableStringFieldUpdateOperationsInput | string | null
    creer_le?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type aimerUpdateWithoutUtilisateurInput = {
    snippet?: SnippetUpdateOneRequiredWithoutAimerNestedInput
  }

  export type aimerUncheckedUpdateWithoutUtilisateurInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
  }

  export type aimerUncheckedUpdateManyWithoutUtilisateurInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
  }

  export type commenterUpdateWithoutUtilisateurInput = {
    date_?: DateTimeFieldUpdateOperationsInput | Date | string
    texte?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: SnippetUpdateOneRequiredWithoutCommenterNestedInput
  }

  export type commenterUncheckedUpdateWithoutUtilisateurInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    date_?: DateTimeFieldUpdateOperationsInput | Date | string
    texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commenterUncheckedUpdateManyWithoutUtilisateurInput = {
    identifiant_snippet?: IntFieldUpdateOperationsInput | number
    date_?: DateTimeFieldUpdateOperationsInput | Date | string
    texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type aimerCreateManySnippetInput = {
    identifiant_utilisateur: number
  }

  export type commenterCreateManySnippetInput = {
    identifiant_utilisateur: number
    date_?: Date | string
    texte?: string | null
  }

  export type snippetTagCreateManySnippetInput = {
    tagId: number
  }

  export type aimerUpdateWithoutSnippetInput = {
    utilisateur?: UtilisateurUpdateOneRequiredWithoutAimerNestedInput
  }

  export type aimerUncheckedUpdateWithoutSnippetInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
  }

  export type aimerUncheckedUpdateManyWithoutSnippetInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
  }

  export type commenterUpdateWithoutSnippetInput = {
    date_?: DateTimeFieldUpdateOperationsInput | Date | string
    texte?: NullableStringFieldUpdateOperationsInput | string | null
    utilisateur?: UtilisateurUpdateOneRequiredWithoutCommenterNestedInput
  }

  export type commenterUncheckedUpdateWithoutSnippetInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    date_?: DateTimeFieldUpdateOperationsInput | Date | string
    texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commenterUncheckedUpdateManyWithoutSnippetInput = {
    identifiant_utilisateur?: IntFieldUpdateOperationsInput | number
    date_?: DateTimeFieldUpdateOperationsInput | Date | string
    texte?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type snippetTagUpdateWithoutSnippetInput = {
    tag?: TagUpdateOneRequiredWithoutSnippetTagNestedInput
  }

  export type snippetTagUncheckedUpdateWithoutSnippetInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type snippetTagUncheckedUpdateManyWithoutSnippetInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type snippetTagCreateManyTagInput = {
    snippetId: number
  }

  export type snippetTagUpdateWithoutTagInput = {
    snippet?: SnippetUpdateOneRequiredWithoutSnippetTagNestedInput
  }

  export type snippetTagUncheckedUpdateWithoutTagInput = {
    snippetId?: IntFieldUpdateOperationsInput | number
  }

  export type snippetTagUncheckedUpdateManyWithoutTagInput = {
    snippetId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}